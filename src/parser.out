Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CONST
    LOWER_THAN_ELSE

Grammar

Rule 0     S' -> starter
Rule 1     starter -> starter builder
Rule 2     starter -> builder
Rule 3     builder -> function
Rule 4     builder -> declaration
Rule 5     function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt
Rule 6     seen_identifier -> <empty>
Rule 7     seen_argument_list -> <empty>
Rule 8     type -> data_type pointer
Rule 9     type -> data_type
Rule 10    data_type -> sign_specifier type_specifier
Rule 11    data_type -> type_specifier
Rule 12    pointer -> MUL pointer
Rule 13    pointer -> MUL
Rule 14    sign_specifier -> SIGNED
Rule 15    sign_specifier -> UNSIGNED
Rule 16    type_specifier -> INT
Rule 17    type_specifier -> SHORT INT
Rule 18    type_specifier -> SHORT
Rule 19    type_specifier -> LONG
Rule 20    type_specifier -> LONG_LONG
Rule 21    type_specifier -> LONG INT
Rule 22    type_specifier -> LONG_LONG INT
Rule 23    type_specifier -> CHAR
Rule 24    type_specifier -> FLOAT
Rule 25    type_specifier -> VOID
Rule 26    type_specifier -> CHAR_STAR
Rule 27    argument_list -> arguments
Rule 28    argument_list -> <empty>
Rule 29    arguments -> arguments COMMA arg
Rule 30    arguments -> arg
Rule 31    arg -> type identifier
Rule 32    stmt -> compound_stmt
Rule 33    stmt -> single_stmt
Rule 34    compound_stmt -> BLP seen_BLP statements BRP
Rule 35    seen_BLP -> <empty>
Rule 36    statements -> statements M stmt
Rule 37    statements -> <empty>
Rule 38    single_stmt -> if_block seen_control
Rule 39    single_stmt -> for_block seen_control
Rule 40    single_stmt -> while_block seen_control
Rule 41    single_stmt -> declaration
Rule 42    single_stmt -> function_call SEMICOLON
Rule 43    single_stmt -> RETURN SEMICOLON
Rule 44    single_stmt -> prntf_call SEMICOLON
Rule 45    single_stmt -> RETURN sub_expr SEMICOLON
Rule 46    single_stmt -> CONTINUE SEMICOLON
Rule 47    single_stmt -> BREAK SEMICOLON
Rule 48    seen_control -> <empty>
Rule 49    expression_stmt -> expression SEMICOLON
Rule 50    expression_stmt -> SEMICOLON
Rule 51    for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
Rule 52    before_loop -> <empty>
Rule 53    after_loop -> <empty>
Rule 54    if_block -> IF LP expression RP M stmt ELSE N M stmt
Rule 55    if_block -> IF LP expression RP M stmt
Rule 56    while_block -> WHILE M LP expression RP M before_loop stmt after_loop
Rule 57    declaration -> type declaration_list SEMICOLON
Rule 58    declaration -> declaration_list SEMICOLON
Rule 59    declaration -> unary_expr
Rule 60    declaration_list -> declaration_list COMMA sub_decl
Rule 61    declaration_list -> sub_decl
Rule 62    sub_decl -> assignment_expr
Rule 63    sub_decl -> identifier
Rule 64    sub_decl -> array_access
Rule 65    expression -> expression COMMA sub_expr
Rule 66    expression -> sub_expr
Rule 67    sub_expr -> sub_expr GR sub_expr
Rule 68    sub_expr -> sub_expr LS sub_expr
Rule 69    sub_expr -> sub_expr EQ sub_expr
Rule 70    sub_expr -> sub_expr NOT_EQ sub_expr
Rule 71    sub_expr -> sub_expr GR_EQ sub_expr
Rule 72    sub_expr -> sub_expr LS_EQ sub_expr
Rule 73    sub_expr -> sub_expr LOGICAL_AND M sub_expr
Rule 74    sub_expr -> sub_expr LOGICAL_OR M sub_expr
Rule 75    sub_expr -> NOT sub_expr
Rule 76    sub_expr -> arithmetic_expr seen_arith
Rule 77    sub_expr -> assignment_expr
Rule 78    sub_expr -> unary_expr
Rule 79    seen_arith -> <empty>
Rule 80    assignment_expr -> lhs assign arithmetic_expr seen_arch
Rule 81    assignment_expr -> lhs assign array_access seen_array
Rule 82    assignment_expr -> lhs assign function_call seen_func_call
Rule 83    assignment_expr -> lhs assign unary_expr seen_unary
Rule 84    seen_arch -> <empty>
Rule 85    seen_array -> <empty>
Rule 86    seen_func_call -> <empty>
Rule 87    seen_unary -> <empty>
Rule 88    unary_expr -> identifier INCREMENT
Rule 89    unary_expr -> identifier DECREMENT
Rule 90    unary_expr -> DECREMENT identifier
Rule 91    unary_expr -> INCREMENT identifier
Rule 92    lhs -> identifier seen_id
Rule 93    lhs -> array_access
Rule 94    seen_id -> <empty>
Rule 95    identifier -> IDENTIFIER
Rule 96    assign -> ASSIGN
Rule 97    assign -> ADD_ASSIGN
Rule 98    assign -> SUB_ASSIGN
Rule 99    assign -> DIV_ASSIGN
Rule 100   assign -> MOD_ASSIGN
Rule 101   assign -> MUL_ASSIGN
Rule 102   arithmetic_expr -> arithmetic_expr ADD arithmetic_expr
Rule 103   arithmetic_expr -> arithmetic_expr SUB arithmetic_expr
Rule 104   arithmetic_expr -> arithmetic_expr MUL arithmetic_expr
Rule 105   arithmetic_expr -> arithmetic_expr DIV arithmetic_expr
Rule 106   arithmetic_expr -> arithmetic_expr MOD arithmetic_expr
Rule 107   arithmetic_expr -> LP arithmetic_expr RP
Rule 108   arithmetic_expr -> SUB arithmetic_expr
Rule 109   arithmetic_expr -> identifier
Rule 110   arithmetic_expr -> constant
Rule 111   constant -> DEC_CONSTANT
Rule 112   constant -> HEX_CONSTANT
Rule 113   constant -> CHAR_CONSTANT
Rule 114   constant -> FLOAT_CONSTANT
Rule 115   array_access -> identifier MLP array_index MRP
Rule 116   array_index -> constant
Rule 117   array_index -> identifier
Rule 118   function_call -> identifier LP parameter_list RP
Rule 119   function_call -> identifier LP RP
Rule 120   prntf_call -> PRNTF LP STRING RP
Rule 121   prntf_call -> PRNTF LP STRING COMMA parameter_list RP
Rule 122   parameter_list -> parameter_list COMMA parameter
Rule 123   parameter_list -> parameter
Rule 124   parameter -> sub_expr
Rule 125   parameter -> STRING
Rule 126   M -> <empty>
Rule 127   N -> <empty>

Terminals, with rules where they appear

ADD                  : 102
ADD_ASSIGN           : 97
ASSIGN               : 96
BLP                  : 34
BREAK                : 47
BRP                  : 34
CHAR                 : 23
CHAR_CONSTANT        : 113
CHAR_STAR            : 26
COMMA                : 29 60 65 121 122
CONST                : 
CONTINUE             : 46
DECREMENT            : 89 90
DEC_CONSTANT         : 111
DIV                  : 105
DIV_ASSIGN           : 99
ELSE                 : 54
EQ                   : 69
FLOAT                : 24
FLOAT_CONSTANT       : 114
FOR                  : 51
GR                   : 67
GR_EQ                : 71
HEX_CONSTANT         : 112
IDENTIFIER           : 95
IF                   : 54 55
INCREMENT            : 88 91
INT                  : 16 17 21 22
LOGICAL_AND          : 73
LOGICAL_OR           : 74
LONG                 : 19 21
LONG_LONG            : 20 22
LOWER_THAN_ELSE      : 
LP                   : 5 51 54 55 56 107 118 119 120 121
LS                   : 68
LS_EQ                : 72
MLP                  : 115
MOD                  : 106
MOD_ASSIGN           : 100
MRP                  : 115
MUL                  : 12 13 104
MUL_ASSIGN           : 101
NOT                  : 75
NOT_EQ               : 70
PRNTF                : 120 121
RETURN               : 43 45
RP                   : 5 51 54 55 56 107 118 119 120 121
SEMICOLON            : 42 43 44 45 46 47 49 50 57 58
SHORT                : 17 18
SIGNED               : 14
STRING               : 120 121 125
SUB                  : 103 108
SUB_ASSIGN           : 98
UNSIGNED             : 15
VOID                 : 25
WHILE                : 56
error                : 

Nonterminals, with rules where they appear

M                    : 36 51 51 51 54 54 55 56 56 73 74
N                    : 51 54
after_loop           : 51 56
arg                  : 29 30
argument_list        : 5
arguments            : 27 29
arithmetic_expr      : 76 80 102 102 103 103 104 104 105 105 106 106 107 108
array_access         : 64 81 93
array_index          : 115
assign               : 80 81 82 83
assignment_expr      : 62 77
before_loop          : 51 56
builder              : 1 2
compound_stmt        : 5 32
constant             : 110 116
data_type            : 8 9
declaration          : 4 41
declaration_list     : 57 58 60
expression           : 49 51 54 55 56 65
expression_stmt      : 51 51
for_block            : 39
function             : 3
function_call        : 42 82
identifier           : 5 31 63 88 89 90 91 92 109 115 117 118 119
if_block             : 38
lhs                  : 80 81 82 83
parameter            : 122 123
parameter_list       : 118 121 122
pointer              : 8 12
prntf_call           : 44
seen_BLP             : 34
seen_arch            : 80
seen_argument_list   : 5
seen_arith           : 76
seen_array           : 81
seen_control         : 38 39 40
seen_func_call       : 82
seen_id              : 92
seen_identifier      : 5
seen_unary           : 83
sign_specifier       : 10
single_stmt          : 33
starter              : 1 0
statements           : 34 36
stmt                 : 36 51 54 54 55 56
sub_decl             : 60 61
sub_expr             : 45 65 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 124
type                 : 5 31 57
type_specifier       : 10 11
unary_expr           : 59 78 83
while_block          : 40

Parsing method: LALR

state 0

    (0) S' -> . starter
    (1) starter -> . starter builder
    (2) starter -> . builder
    (3) builder -> . function
    (4) builder -> . declaration
    (5) function -> . type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (95) identifier -> . IDENTIFIER
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    starter                        shift and go to state 1
    builder                        shift and go to state 2
    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5
    identifier                     shift and go to state 6
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 1

    (0) S' -> starter .
    (1) starter -> starter . builder
    (3) builder -> . function
    (4) builder -> . declaration
    (5) function -> . type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (95) identifier -> . IDENTIFIER
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    builder                        shift and go to state 29
    function                       shift and go to state 3
    declaration                    shift and go to state 4
    type                           shift and go to state 5
    identifier                     shift and go to state 6
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 2

    (2) starter -> builder .

    DECREMENT       reduce using rule 2 (starter -> builder .)
    INCREMENT       reduce using rule 2 (starter -> builder .)
    IDENTIFIER      reduce using rule 2 (starter -> builder .)
    SIGNED          reduce using rule 2 (starter -> builder .)
    UNSIGNED        reduce using rule 2 (starter -> builder .)
    INT             reduce using rule 2 (starter -> builder .)
    SHORT           reduce using rule 2 (starter -> builder .)
    LONG            reduce using rule 2 (starter -> builder .)
    LONG_LONG       reduce using rule 2 (starter -> builder .)
    CHAR            reduce using rule 2 (starter -> builder .)
    FLOAT           reduce using rule 2 (starter -> builder .)
    VOID            reduce using rule 2 (starter -> builder .)
    CHAR_STAR       reduce using rule 2 (starter -> builder .)
    $end            reduce using rule 2 (starter -> builder .)


state 3

    (3) builder -> function .

    DECREMENT       reduce using rule 3 (builder -> function .)
    INCREMENT       reduce using rule 3 (builder -> function .)
    IDENTIFIER      reduce using rule 3 (builder -> function .)
    SIGNED          reduce using rule 3 (builder -> function .)
    UNSIGNED        reduce using rule 3 (builder -> function .)
    INT             reduce using rule 3 (builder -> function .)
    SHORT           reduce using rule 3 (builder -> function .)
    LONG            reduce using rule 3 (builder -> function .)
    LONG_LONG       reduce using rule 3 (builder -> function .)
    CHAR            reduce using rule 3 (builder -> function .)
    FLOAT           reduce using rule 3 (builder -> function .)
    VOID            reduce using rule 3 (builder -> function .)
    CHAR_STAR       reduce using rule 3 (builder -> function .)
    $end            reduce using rule 3 (builder -> function .)


state 4

    (4) builder -> declaration .

    DECREMENT       reduce using rule 4 (builder -> declaration .)
    INCREMENT       reduce using rule 4 (builder -> declaration .)
    IDENTIFIER      reduce using rule 4 (builder -> declaration .)
    SIGNED          reduce using rule 4 (builder -> declaration .)
    UNSIGNED        reduce using rule 4 (builder -> declaration .)
    INT             reduce using rule 4 (builder -> declaration .)
    SHORT           reduce using rule 4 (builder -> declaration .)
    LONG            reduce using rule 4 (builder -> declaration .)
    LONG_LONG       reduce using rule 4 (builder -> declaration .)
    CHAR            reduce using rule 4 (builder -> declaration .)
    FLOAT           reduce using rule 4 (builder -> declaration .)
    VOID            reduce using rule 4 (builder -> declaration .)
    CHAR_STAR       reduce using rule 4 (builder -> declaration .)
    $end            reduce using rule 4 (builder -> declaration .)


state 5

    (5) function -> type . identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt
    (57) declaration -> type . declaration_list SEMICOLON
    (95) identifier -> . IDENTIFIER
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    IDENTIFIER      shift and go to state 17

    identifier                     shift and go to state 30
    declaration_list               shift and go to state 31
    sub_decl                       shift and go to state 10
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 6

    (88) unary_expr -> identifier . INCREMENT
    (89) unary_expr -> identifier . DECREMENT
    (63) sub_decl -> identifier .
    (115) array_access -> identifier . MLP array_index MRP
    (92) lhs -> identifier . seen_id
    (94) seen_id -> .

    INCREMENT       shift and go to state 32
    DECREMENT       shift and go to state 33
    SEMICOLON       reduce using rule 63 (sub_decl -> identifier .)
    COMMA           reduce using rule 63 (sub_decl -> identifier .)
    MLP             shift and go to state 34
    ASSIGN          reduce using rule 94 (seen_id -> .)
    ADD_ASSIGN      reduce using rule 94 (seen_id -> .)
    SUB_ASSIGN      reduce using rule 94 (seen_id -> .)
    DIV_ASSIGN      reduce using rule 94 (seen_id -> .)
    MOD_ASSIGN      reduce using rule 94 (seen_id -> .)
    MUL_ASSIGN      reduce using rule 94 (seen_id -> .)

    seen_id                        shift and go to state 35

state 7

    (58) declaration -> declaration_list . SEMICOLON
    (60) declaration_list -> declaration_list . COMMA sub_decl

    SEMICOLON       shift and go to state 36
    COMMA           shift and go to state 37


state 8

    (59) declaration -> unary_expr .

    DECREMENT       reduce using rule 59 (declaration -> unary_expr .)
    INCREMENT       reduce using rule 59 (declaration -> unary_expr .)
    IDENTIFIER      reduce using rule 59 (declaration -> unary_expr .)
    SIGNED          reduce using rule 59 (declaration -> unary_expr .)
    UNSIGNED        reduce using rule 59 (declaration -> unary_expr .)
    INT             reduce using rule 59 (declaration -> unary_expr .)
    SHORT           reduce using rule 59 (declaration -> unary_expr .)
    LONG            reduce using rule 59 (declaration -> unary_expr .)
    LONG_LONG       reduce using rule 59 (declaration -> unary_expr .)
    CHAR            reduce using rule 59 (declaration -> unary_expr .)
    FLOAT           reduce using rule 59 (declaration -> unary_expr .)
    VOID            reduce using rule 59 (declaration -> unary_expr .)
    CHAR_STAR       reduce using rule 59 (declaration -> unary_expr .)
    $end            reduce using rule 59 (declaration -> unary_expr .)
    BRP             reduce using rule 59 (declaration -> unary_expr .)
    BLP             reduce using rule 59 (declaration -> unary_expr .)
    RETURN          reduce using rule 59 (declaration -> unary_expr .)
    CONTINUE        reduce using rule 59 (declaration -> unary_expr .)
    BREAK           reduce using rule 59 (declaration -> unary_expr .)
    IF              reduce using rule 59 (declaration -> unary_expr .)
    FOR             reduce using rule 59 (declaration -> unary_expr .)
    WHILE           reduce using rule 59 (declaration -> unary_expr .)
    PRNTF           reduce using rule 59 (declaration -> unary_expr .)
    ELSE            reduce using rule 59 (declaration -> unary_expr .)


state 9

    (8) type -> data_type . pointer
    (9) type -> data_type .
    (12) pointer -> . MUL pointer
    (13) pointer -> . MUL

    IDENTIFIER      reduce using rule 9 (type -> data_type .)
    MUL             shift and go to state 39

    pointer                        shift and go to state 38

state 10

    (61) declaration_list -> sub_decl .

    SEMICOLON       reduce using rule 61 (declaration_list -> sub_decl .)
    COMMA           reduce using rule 61 (declaration_list -> sub_decl .)


state 11

    (91) unary_expr -> INCREMENT . identifier
    (95) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier                     shift and go to state 40

state 12

    (90) unary_expr -> DECREMENT . identifier
    (95) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier                     shift and go to state 41

state 13

    (10) data_type -> sign_specifier . type_specifier
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR

    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    type_specifier                 shift and go to state 42

state 14

    (11) data_type -> type_specifier .

    MUL             reduce using rule 11 (data_type -> type_specifier .)
    IDENTIFIER      reduce using rule 11 (data_type -> type_specifier .)


state 15

    (62) sub_decl -> assignment_expr .

    SEMICOLON       reduce using rule 62 (sub_decl -> assignment_expr .)
    COMMA           reduce using rule 62 (sub_decl -> assignment_expr .)


state 16

    (64) sub_decl -> array_access .
    (93) lhs -> array_access .

    SEMICOLON       reduce using rule 64 (sub_decl -> array_access .)
    COMMA           reduce using rule 64 (sub_decl -> array_access .)
    ASSIGN          reduce using rule 93 (lhs -> array_access .)
    ADD_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    SUB_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    DIV_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    MOD_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    MUL_ASSIGN      reduce using rule 93 (lhs -> array_access .)


state 17

    (95) identifier -> IDENTIFIER .

    INCREMENT       reduce using rule 95 (identifier -> IDENTIFIER .)
    DECREMENT       reduce using rule 95 (identifier -> IDENTIFIER .)
    MLP             reduce using rule 95 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 95 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 95 (identifier -> IDENTIFIER .)
    ASSIGN          reduce using rule 95 (identifier -> IDENTIFIER .)
    ADD_ASSIGN      reduce using rule 95 (identifier -> IDENTIFIER .)
    SUB_ASSIGN      reduce using rule 95 (identifier -> IDENTIFIER .)
    DIV_ASSIGN      reduce using rule 95 (identifier -> IDENTIFIER .)
    MOD_ASSIGN      reduce using rule 95 (identifier -> IDENTIFIER .)
    MUL_ASSIGN      reduce using rule 95 (identifier -> IDENTIFIER .)
    LP              reduce using rule 95 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 95 (identifier -> IDENTIFIER .)
    SIGNED          reduce using rule 95 (identifier -> IDENTIFIER .)
    UNSIGNED        reduce using rule 95 (identifier -> IDENTIFIER .)
    INT             reduce using rule 95 (identifier -> IDENTIFIER .)
    SHORT           reduce using rule 95 (identifier -> IDENTIFIER .)
    LONG            reduce using rule 95 (identifier -> IDENTIFIER .)
    LONG_LONG       reduce using rule 95 (identifier -> IDENTIFIER .)
    CHAR            reduce using rule 95 (identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 95 (identifier -> IDENTIFIER .)
    VOID            reduce using rule 95 (identifier -> IDENTIFIER .)
    CHAR_STAR       reduce using rule 95 (identifier -> IDENTIFIER .)
    $end            reduce using rule 95 (identifier -> IDENTIFIER .)
    GR              reduce using rule 95 (identifier -> IDENTIFIER .)
    LS              reduce using rule 95 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 95 (identifier -> IDENTIFIER .)
    NOT_EQ          reduce using rule 95 (identifier -> IDENTIFIER .)
    GR_EQ           reduce using rule 95 (identifier -> IDENTIFIER .)
    LS_EQ           reduce using rule 95 (identifier -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 95 (identifier -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 95 (identifier -> IDENTIFIER .)
    RP              reduce using rule 95 (identifier -> IDENTIFIER .)
    BRP             reduce using rule 95 (identifier -> IDENTIFIER .)
    BLP             reduce using rule 95 (identifier -> IDENTIFIER .)
    RETURN          reduce using rule 95 (identifier -> IDENTIFIER .)
    CONTINUE        reduce using rule 95 (identifier -> IDENTIFIER .)
    BREAK           reduce using rule 95 (identifier -> IDENTIFIER .)
    IF              reduce using rule 95 (identifier -> IDENTIFIER .)
    FOR             reduce using rule 95 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 95 (identifier -> IDENTIFIER .)
    PRNTF           reduce using rule 95 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 95 (identifier -> IDENTIFIER .)
    MRP             reduce using rule 95 (identifier -> IDENTIFIER .)
    ADD             reduce using rule 95 (identifier -> IDENTIFIER .)
    SUB             reduce using rule 95 (identifier -> IDENTIFIER .)
    MUL             reduce using rule 95 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 95 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 95 (identifier -> IDENTIFIER .)


state 18

    (14) sign_specifier -> SIGNED .

    INT             reduce using rule 14 (sign_specifier -> SIGNED .)
    SHORT           reduce using rule 14 (sign_specifier -> SIGNED .)
    LONG            reduce using rule 14 (sign_specifier -> SIGNED .)
    LONG_LONG       reduce using rule 14 (sign_specifier -> SIGNED .)
    CHAR            reduce using rule 14 (sign_specifier -> SIGNED .)
    FLOAT           reduce using rule 14 (sign_specifier -> SIGNED .)
    VOID            reduce using rule 14 (sign_specifier -> SIGNED .)
    CHAR_STAR       reduce using rule 14 (sign_specifier -> SIGNED .)


state 19

    (15) sign_specifier -> UNSIGNED .

    INT             reduce using rule 15 (sign_specifier -> UNSIGNED .)
    SHORT           reduce using rule 15 (sign_specifier -> UNSIGNED .)
    LONG            reduce using rule 15 (sign_specifier -> UNSIGNED .)
    LONG_LONG       reduce using rule 15 (sign_specifier -> UNSIGNED .)
    CHAR            reduce using rule 15 (sign_specifier -> UNSIGNED .)
    FLOAT           reduce using rule 15 (sign_specifier -> UNSIGNED .)
    VOID            reduce using rule 15 (sign_specifier -> UNSIGNED .)
    CHAR_STAR       reduce using rule 15 (sign_specifier -> UNSIGNED .)


state 20

    (16) type_specifier -> INT .

    MUL             reduce using rule 16 (type_specifier -> INT .)
    IDENTIFIER      reduce using rule 16 (type_specifier -> INT .)


state 21

    (17) type_specifier -> SHORT . INT
    (18) type_specifier -> SHORT .

    INT             shift and go to state 43
    MUL             reduce using rule 18 (type_specifier -> SHORT .)
    IDENTIFIER      reduce using rule 18 (type_specifier -> SHORT .)


state 22

    (19) type_specifier -> LONG .
    (21) type_specifier -> LONG . INT

    MUL             reduce using rule 19 (type_specifier -> LONG .)
    IDENTIFIER      reduce using rule 19 (type_specifier -> LONG .)
    INT             shift and go to state 44


state 23

    (20) type_specifier -> LONG_LONG .
    (22) type_specifier -> LONG_LONG . INT

    MUL             reduce using rule 20 (type_specifier -> LONG_LONG .)
    IDENTIFIER      reduce using rule 20 (type_specifier -> LONG_LONG .)
    INT             shift and go to state 45


state 24

    (23) type_specifier -> CHAR .

    MUL             reduce using rule 23 (type_specifier -> CHAR .)
    IDENTIFIER      reduce using rule 23 (type_specifier -> CHAR .)


state 25

    (24) type_specifier -> FLOAT .

    MUL             reduce using rule 24 (type_specifier -> FLOAT .)
    IDENTIFIER      reduce using rule 24 (type_specifier -> FLOAT .)


state 26

    (25) type_specifier -> VOID .

    MUL             reduce using rule 25 (type_specifier -> VOID .)
    IDENTIFIER      reduce using rule 25 (type_specifier -> VOID .)


state 27

    (26) type_specifier -> CHAR_STAR .

    MUL             reduce using rule 26 (type_specifier -> CHAR_STAR .)
    IDENTIFIER      reduce using rule 26 (type_specifier -> CHAR_STAR .)


state 28

    (80) assignment_expr -> lhs . assign arithmetic_expr seen_arch
    (81) assignment_expr -> lhs . assign array_access seen_array
    (82) assignment_expr -> lhs . assign function_call seen_func_call
    (83) assignment_expr -> lhs . assign unary_expr seen_unary
    (96) assign -> . ASSIGN
    (97) assign -> . ADD_ASSIGN
    (98) assign -> . SUB_ASSIGN
    (99) assign -> . DIV_ASSIGN
    (100) assign -> . MOD_ASSIGN
    (101) assign -> . MUL_ASSIGN

    ASSIGN          shift and go to state 47
    ADD_ASSIGN      shift and go to state 48
    SUB_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    MOD_ASSIGN      shift and go to state 51
    MUL_ASSIGN      shift and go to state 52

    assign                         shift and go to state 46

state 29

    (1) starter -> starter builder .

    DECREMENT       reduce using rule 1 (starter -> starter builder .)
    INCREMENT       reduce using rule 1 (starter -> starter builder .)
    IDENTIFIER      reduce using rule 1 (starter -> starter builder .)
    SIGNED          reduce using rule 1 (starter -> starter builder .)
    UNSIGNED        reduce using rule 1 (starter -> starter builder .)
    INT             reduce using rule 1 (starter -> starter builder .)
    SHORT           reduce using rule 1 (starter -> starter builder .)
    LONG            reduce using rule 1 (starter -> starter builder .)
    LONG_LONG       reduce using rule 1 (starter -> starter builder .)
    CHAR            reduce using rule 1 (starter -> starter builder .)
    FLOAT           reduce using rule 1 (starter -> starter builder .)
    VOID            reduce using rule 1 (starter -> starter builder .)
    CHAR_STAR       reduce using rule 1 (starter -> starter builder .)
    $end            reduce using rule 1 (starter -> starter builder .)


state 30

    (5) function -> type identifier . seen_identifier LP argument_list seen_argument_list RP compound_stmt
    (63) sub_decl -> identifier .
    (115) array_access -> identifier . MLP array_index MRP
    (92) lhs -> identifier . seen_id
    (6) seen_identifier -> .
    (94) seen_id -> .

    SEMICOLON       reduce using rule 63 (sub_decl -> identifier .)
    COMMA           reduce using rule 63 (sub_decl -> identifier .)
    MLP             shift and go to state 34
    LP              reduce using rule 6 (seen_identifier -> .)
    ASSIGN          reduce using rule 94 (seen_id -> .)
    ADD_ASSIGN      reduce using rule 94 (seen_id -> .)
    SUB_ASSIGN      reduce using rule 94 (seen_id -> .)
    DIV_ASSIGN      reduce using rule 94 (seen_id -> .)
    MOD_ASSIGN      reduce using rule 94 (seen_id -> .)
    MUL_ASSIGN      reduce using rule 94 (seen_id -> .)

    seen_identifier                shift and go to state 53
    seen_id                        shift and go to state 35

state 31

    (57) declaration -> type declaration_list . SEMICOLON
    (60) declaration_list -> declaration_list . COMMA sub_decl

    SEMICOLON       shift and go to state 54
    COMMA           shift and go to state 37


state 32

    (88) unary_expr -> identifier INCREMENT .

    DECREMENT       reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    INCREMENT       reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    IDENTIFIER      reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    SIGNED          reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    UNSIGNED        reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    INT             reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    SHORT           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LONG            reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LONG_LONG       reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    CHAR            reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    FLOAT           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    VOID            reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    CHAR_STAR       reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    $end            reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    SEMICOLON       reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    COMMA           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    GR              reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LS              reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    EQ              reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    NOT_EQ          reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    GR_EQ           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LS_EQ           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LOGICAL_AND     reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    LOGICAL_OR      reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    RP              reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    BRP             reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    BLP             reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    RETURN          reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    CONTINUE        reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    BREAK           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    IF              reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    FOR             reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    WHILE           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    PRNTF           reduce using rule 88 (unary_expr -> identifier INCREMENT .)
    ELSE            reduce using rule 88 (unary_expr -> identifier INCREMENT .)


state 33

    (89) unary_expr -> identifier DECREMENT .

    DECREMENT       reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    INCREMENT       reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    IDENTIFIER      reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    SIGNED          reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    UNSIGNED        reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    INT             reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    SHORT           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LONG            reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LONG_LONG       reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    CHAR            reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    FLOAT           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    VOID            reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    CHAR_STAR       reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    $end            reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    SEMICOLON       reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    COMMA           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    GR              reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LS              reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    EQ              reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    NOT_EQ          reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    GR_EQ           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LS_EQ           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LOGICAL_AND     reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    LOGICAL_OR      reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    RP              reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    BRP             reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    BLP             reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    RETURN          reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    CONTINUE        reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    BREAK           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    IF              reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    FOR             reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    WHILE           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    PRNTF           reduce using rule 89 (unary_expr -> identifier DECREMENT .)
    ELSE            reduce using rule 89 (unary_expr -> identifier DECREMENT .)


state 34

    (115) array_access -> identifier MLP . array_index MRP
    (116) array_index -> . constant
    (117) array_index -> . identifier
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (95) identifier -> . IDENTIFIER

    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61
    IDENTIFIER      shift and go to state 17

    identifier                     shift and go to state 55
    array_index                    shift and go to state 56
    constant                       shift and go to state 57

state 35

    (92) lhs -> identifier seen_id .

    ASSIGN          reduce using rule 92 (lhs -> identifier seen_id .)
    ADD_ASSIGN      reduce using rule 92 (lhs -> identifier seen_id .)
    SUB_ASSIGN      reduce using rule 92 (lhs -> identifier seen_id .)
    DIV_ASSIGN      reduce using rule 92 (lhs -> identifier seen_id .)
    MOD_ASSIGN      reduce using rule 92 (lhs -> identifier seen_id .)
    MUL_ASSIGN      reduce using rule 92 (lhs -> identifier seen_id .)


state 36

    (58) declaration -> declaration_list SEMICOLON .

    DECREMENT       reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    INCREMENT       reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    IDENTIFIER      reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    SIGNED          reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    UNSIGNED        reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    INT             reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    SHORT           reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    LONG            reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    LONG_LONG       reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    CHAR            reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    FLOAT           reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    VOID            reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    CHAR_STAR       reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    $end            reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    BRP             reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    BLP             reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    RETURN          reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    CONTINUE        reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    BREAK           reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    IF              reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    FOR             reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    WHILE           reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    PRNTF           reduce using rule 58 (declaration -> declaration_list SEMICOLON .)
    ELSE            reduce using rule 58 (declaration -> declaration_list SEMICOLON .)


state 37

    (60) declaration_list -> declaration_list COMMA . sub_decl
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (95) identifier -> . IDENTIFIER
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    IDENTIFIER      shift and go to state 17

    sub_decl                       shift and go to state 62
    assignment_expr                shift and go to state 15
    identifier                     shift and go to state 63
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 38

    (8) type -> data_type pointer .

    IDENTIFIER      reduce using rule 8 (type -> data_type pointer .)


state 39

    (12) pointer -> MUL . pointer
    (13) pointer -> MUL .
    (12) pointer -> . MUL pointer
    (13) pointer -> . MUL

    IDENTIFIER      reduce using rule 13 (pointer -> MUL .)
    MUL             shift and go to state 39

    pointer                        shift and go to state 64

state 40

    (91) unary_expr -> INCREMENT identifier .

    DECREMENT       reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    INCREMENT       reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    IDENTIFIER      reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    SIGNED          reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    UNSIGNED        reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    INT             reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    SHORT           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LONG            reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LONG_LONG       reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    CHAR            reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    FLOAT           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    VOID            reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    CHAR_STAR       reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    $end            reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    SEMICOLON       reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    COMMA           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    GR              reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LS              reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    EQ              reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    NOT_EQ          reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    GR_EQ           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LS_EQ           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LOGICAL_AND     reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    LOGICAL_OR      reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    RP              reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    BRP             reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    BLP             reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    RETURN          reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    CONTINUE        reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    BREAK           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    IF              reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    FOR             reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    WHILE           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    PRNTF           reduce using rule 91 (unary_expr -> INCREMENT identifier .)
    ELSE            reduce using rule 91 (unary_expr -> INCREMENT identifier .)


state 41

    (90) unary_expr -> DECREMENT identifier .

    DECREMENT       reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    INCREMENT       reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    IDENTIFIER      reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    SIGNED          reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    UNSIGNED        reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    INT             reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    SHORT           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LONG            reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LONG_LONG       reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    CHAR            reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    FLOAT           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    VOID            reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    CHAR_STAR       reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    $end            reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    SEMICOLON       reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    COMMA           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    GR              reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LS              reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    EQ              reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    NOT_EQ          reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    GR_EQ           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LS_EQ           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LOGICAL_AND     reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    LOGICAL_OR      reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    RP              reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    BRP             reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    BLP             reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    RETURN          reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    CONTINUE        reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    BREAK           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    IF              reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    FOR             reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    WHILE           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    PRNTF           reduce using rule 90 (unary_expr -> DECREMENT identifier .)
    ELSE            reduce using rule 90 (unary_expr -> DECREMENT identifier .)


state 42

    (10) data_type -> sign_specifier type_specifier .

    MUL             reduce using rule 10 (data_type -> sign_specifier type_specifier .)
    IDENTIFIER      reduce using rule 10 (data_type -> sign_specifier type_specifier .)


state 43

    (17) type_specifier -> SHORT INT .

    MUL             reduce using rule 17 (type_specifier -> SHORT INT .)
    IDENTIFIER      reduce using rule 17 (type_specifier -> SHORT INT .)


state 44

    (21) type_specifier -> LONG INT .

    MUL             reduce using rule 21 (type_specifier -> LONG INT .)
    IDENTIFIER      reduce using rule 21 (type_specifier -> LONG INT .)


state 45

    (22) type_specifier -> LONG_LONG INT .

    MUL             reduce using rule 22 (type_specifier -> LONG_LONG INT .)
    IDENTIFIER      reduce using rule 22 (type_specifier -> LONG_LONG INT .)


state 46

    (80) assignment_expr -> lhs assign . arithmetic_expr seen_arch
    (81) assignment_expr -> lhs assign . array_access seen_array
    (82) assignment_expr -> lhs assign . function_call seen_func_call
    (83) assignment_expr -> lhs assign . unary_expr seen_unary
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (115) array_access -> . identifier MLP array_index MRP
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 65
    array_access                   shift and go to state 66
    function_call                  shift and go to state 67
    unary_expr                     shift and go to state 68
    identifier                     shift and go to state 71
    constant                       shift and go to state 72

state 47

    (96) assign -> ASSIGN .

    LP              reduce using rule 96 (assign -> ASSIGN .)
    SUB             reduce using rule 96 (assign -> ASSIGN .)
    DECREMENT       reduce using rule 96 (assign -> ASSIGN .)
    INCREMENT       reduce using rule 96 (assign -> ASSIGN .)
    IDENTIFIER      reduce using rule 96 (assign -> ASSIGN .)
    DEC_CONSTANT    reduce using rule 96 (assign -> ASSIGN .)
    HEX_CONSTANT    reduce using rule 96 (assign -> ASSIGN .)
    CHAR_CONSTANT   reduce using rule 96 (assign -> ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 96 (assign -> ASSIGN .)


state 48

    (97) assign -> ADD_ASSIGN .

    LP              reduce using rule 97 (assign -> ADD_ASSIGN .)
    SUB             reduce using rule 97 (assign -> ADD_ASSIGN .)
    DECREMENT       reduce using rule 97 (assign -> ADD_ASSIGN .)
    INCREMENT       reduce using rule 97 (assign -> ADD_ASSIGN .)
    IDENTIFIER      reduce using rule 97 (assign -> ADD_ASSIGN .)
    DEC_CONSTANT    reduce using rule 97 (assign -> ADD_ASSIGN .)
    HEX_CONSTANT    reduce using rule 97 (assign -> ADD_ASSIGN .)
    CHAR_CONSTANT   reduce using rule 97 (assign -> ADD_ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 97 (assign -> ADD_ASSIGN .)


state 49

    (98) assign -> SUB_ASSIGN .

    LP              reduce using rule 98 (assign -> SUB_ASSIGN .)
    SUB             reduce using rule 98 (assign -> SUB_ASSIGN .)
    DECREMENT       reduce using rule 98 (assign -> SUB_ASSIGN .)
    INCREMENT       reduce using rule 98 (assign -> SUB_ASSIGN .)
    IDENTIFIER      reduce using rule 98 (assign -> SUB_ASSIGN .)
    DEC_CONSTANT    reduce using rule 98 (assign -> SUB_ASSIGN .)
    HEX_CONSTANT    reduce using rule 98 (assign -> SUB_ASSIGN .)
    CHAR_CONSTANT   reduce using rule 98 (assign -> SUB_ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 98 (assign -> SUB_ASSIGN .)


state 50

    (99) assign -> DIV_ASSIGN .

    LP              reduce using rule 99 (assign -> DIV_ASSIGN .)
    SUB             reduce using rule 99 (assign -> DIV_ASSIGN .)
    DECREMENT       reduce using rule 99 (assign -> DIV_ASSIGN .)
    INCREMENT       reduce using rule 99 (assign -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 99 (assign -> DIV_ASSIGN .)
    DEC_CONSTANT    reduce using rule 99 (assign -> DIV_ASSIGN .)
    HEX_CONSTANT    reduce using rule 99 (assign -> DIV_ASSIGN .)
    CHAR_CONSTANT   reduce using rule 99 (assign -> DIV_ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 99 (assign -> DIV_ASSIGN .)


state 51

    (100) assign -> MOD_ASSIGN .

    LP              reduce using rule 100 (assign -> MOD_ASSIGN .)
    SUB             reduce using rule 100 (assign -> MOD_ASSIGN .)
    DECREMENT       reduce using rule 100 (assign -> MOD_ASSIGN .)
    INCREMENT       reduce using rule 100 (assign -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 100 (assign -> MOD_ASSIGN .)
    DEC_CONSTANT    reduce using rule 100 (assign -> MOD_ASSIGN .)
    HEX_CONSTANT    reduce using rule 100 (assign -> MOD_ASSIGN .)
    CHAR_CONSTANT   reduce using rule 100 (assign -> MOD_ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 100 (assign -> MOD_ASSIGN .)


state 52

    (101) assign -> MUL_ASSIGN .

    LP              reduce using rule 101 (assign -> MUL_ASSIGN .)
    SUB             reduce using rule 101 (assign -> MUL_ASSIGN .)
    DECREMENT       reduce using rule 101 (assign -> MUL_ASSIGN .)
    INCREMENT       reduce using rule 101 (assign -> MUL_ASSIGN .)
    IDENTIFIER      reduce using rule 101 (assign -> MUL_ASSIGN .)
    DEC_CONSTANT    reduce using rule 101 (assign -> MUL_ASSIGN .)
    HEX_CONSTANT    reduce using rule 101 (assign -> MUL_ASSIGN .)
    CHAR_CONSTANT   reduce using rule 101 (assign -> MUL_ASSIGN .)
    FLOAT_CONSTANT  reduce using rule 101 (assign -> MUL_ASSIGN .)


state 53

    (5) function -> type identifier seen_identifier . LP argument_list seen_argument_list RP compound_stmt

    LP              shift and go to state 73


state 54

    (57) declaration -> type declaration_list SEMICOLON .

    DECREMENT       reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    INCREMENT       reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    SIGNED          reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    UNSIGNED        reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    INT             reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    SHORT           reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    LONG            reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    LONG_LONG       reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    CHAR            reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    FLOAT           reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    VOID            reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    CHAR_STAR       reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    $end            reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    BRP             reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    BLP             reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    RETURN          reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    CONTINUE        reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    BREAK           reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    IF              reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    FOR             reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    WHILE           reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    PRNTF           reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)
    ELSE            reduce using rule 57 (declaration -> type declaration_list SEMICOLON .)


state 55

    (117) array_index -> identifier .

    MRP             reduce using rule 117 (array_index -> identifier .)


state 56

    (115) array_access -> identifier MLP array_index . MRP

    MRP             shift and go to state 74


state 57

    (116) array_index -> constant .

    MRP             reduce using rule 116 (array_index -> constant .)


state 58

    (111) constant -> DEC_CONSTANT .

    MRP             reduce using rule 111 (constant -> DEC_CONSTANT .)
    ADD             reduce using rule 111 (constant -> DEC_CONSTANT .)
    SUB             reduce using rule 111 (constant -> DEC_CONSTANT .)
    MUL             reduce using rule 111 (constant -> DEC_CONSTANT .)
    DIV             reduce using rule 111 (constant -> DEC_CONSTANT .)
    MOD             reduce using rule 111 (constant -> DEC_CONSTANT .)
    SEMICOLON       reduce using rule 111 (constant -> DEC_CONSTANT .)
    COMMA           reduce using rule 111 (constant -> DEC_CONSTANT .)
    GR              reduce using rule 111 (constant -> DEC_CONSTANT .)
    LS              reduce using rule 111 (constant -> DEC_CONSTANT .)
    EQ              reduce using rule 111 (constant -> DEC_CONSTANT .)
    NOT_EQ          reduce using rule 111 (constant -> DEC_CONSTANT .)
    GR_EQ           reduce using rule 111 (constant -> DEC_CONSTANT .)
    LS_EQ           reduce using rule 111 (constant -> DEC_CONSTANT .)
    LOGICAL_AND     reduce using rule 111 (constant -> DEC_CONSTANT .)
    LOGICAL_OR      reduce using rule 111 (constant -> DEC_CONSTANT .)
    RP              reduce using rule 111 (constant -> DEC_CONSTANT .)


state 59

    (112) constant -> HEX_CONSTANT .

    MRP             reduce using rule 112 (constant -> HEX_CONSTANT .)
    ADD             reduce using rule 112 (constant -> HEX_CONSTANT .)
    SUB             reduce using rule 112 (constant -> HEX_CONSTANT .)
    MUL             reduce using rule 112 (constant -> HEX_CONSTANT .)
    DIV             reduce using rule 112 (constant -> HEX_CONSTANT .)
    MOD             reduce using rule 112 (constant -> HEX_CONSTANT .)
    SEMICOLON       reduce using rule 112 (constant -> HEX_CONSTANT .)
    COMMA           reduce using rule 112 (constant -> HEX_CONSTANT .)
    GR              reduce using rule 112 (constant -> HEX_CONSTANT .)
    LS              reduce using rule 112 (constant -> HEX_CONSTANT .)
    EQ              reduce using rule 112 (constant -> HEX_CONSTANT .)
    NOT_EQ          reduce using rule 112 (constant -> HEX_CONSTANT .)
    GR_EQ           reduce using rule 112 (constant -> HEX_CONSTANT .)
    LS_EQ           reduce using rule 112 (constant -> HEX_CONSTANT .)
    LOGICAL_AND     reduce using rule 112 (constant -> HEX_CONSTANT .)
    LOGICAL_OR      reduce using rule 112 (constant -> HEX_CONSTANT .)
    RP              reduce using rule 112 (constant -> HEX_CONSTANT .)


state 60

    (113) constant -> CHAR_CONSTANT .

    MRP             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    ADD             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    SUB             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    MUL             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    DIV             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    MOD             reduce using rule 113 (constant -> CHAR_CONSTANT .)
    SEMICOLON       reduce using rule 113 (constant -> CHAR_CONSTANT .)
    COMMA           reduce using rule 113 (constant -> CHAR_CONSTANT .)
    GR              reduce using rule 113 (constant -> CHAR_CONSTANT .)
    LS              reduce using rule 113 (constant -> CHAR_CONSTANT .)
    EQ              reduce using rule 113 (constant -> CHAR_CONSTANT .)
    NOT_EQ          reduce using rule 113 (constant -> CHAR_CONSTANT .)
    GR_EQ           reduce using rule 113 (constant -> CHAR_CONSTANT .)
    LS_EQ           reduce using rule 113 (constant -> CHAR_CONSTANT .)
    LOGICAL_AND     reduce using rule 113 (constant -> CHAR_CONSTANT .)
    LOGICAL_OR      reduce using rule 113 (constant -> CHAR_CONSTANT .)
    RP              reduce using rule 113 (constant -> CHAR_CONSTANT .)


state 61

    (114) constant -> FLOAT_CONSTANT .

    MRP             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    ADD             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    SUB             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    MUL             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    DIV             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    MOD             reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    SEMICOLON       reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    COMMA           reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    GR              reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    LS              reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    EQ              reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    NOT_EQ          reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    GR_EQ           reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    LS_EQ           reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    LOGICAL_AND     reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    LOGICAL_OR      reduce using rule 114 (constant -> FLOAT_CONSTANT .)
    RP              reduce using rule 114 (constant -> FLOAT_CONSTANT .)


state 62

    (60) declaration_list -> declaration_list COMMA sub_decl .

    SEMICOLON       reduce using rule 60 (declaration_list -> declaration_list COMMA sub_decl .)
    COMMA           reduce using rule 60 (declaration_list -> declaration_list COMMA sub_decl .)


state 63

    (63) sub_decl -> identifier .
    (115) array_access -> identifier . MLP array_index MRP
    (92) lhs -> identifier . seen_id
    (94) seen_id -> .

    SEMICOLON       reduce using rule 63 (sub_decl -> identifier .)
    COMMA           reduce using rule 63 (sub_decl -> identifier .)
    MLP             shift and go to state 34
    ASSIGN          reduce using rule 94 (seen_id -> .)
    ADD_ASSIGN      reduce using rule 94 (seen_id -> .)
    SUB_ASSIGN      reduce using rule 94 (seen_id -> .)
    DIV_ASSIGN      reduce using rule 94 (seen_id -> .)
    MOD_ASSIGN      reduce using rule 94 (seen_id -> .)
    MUL_ASSIGN      reduce using rule 94 (seen_id -> .)

    seen_id                        shift and go to state 35

state 64

    (12) pointer -> MUL pointer .

    IDENTIFIER      reduce using rule 12 (pointer -> MUL pointer .)


state 65

    (80) assignment_expr -> lhs assign arithmetic_expr . seen_arch
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr
    (84) seen_arch -> .

    ADD             shift and go to state 76
    SUB             shift and go to state 77
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    SEMICOLON       reduce using rule 84 (seen_arch -> .)
    COMMA           reduce using rule 84 (seen_arch -> .)
    GR              reduce using rule 84 (seen_arch -> .)
    LS              reduce using rule 84 (seen_arch -> .)
    EQ              reduce using rule 84 (seen_arch -> .)
    NOT_EQ          reduce using rule 84 (seen_arch -> .)
    GR_EQ           reduce using rule 84 (seen_arch -> .)
    LS_EQ           reduce using rule 84 (seen_arch -> .)
    LOGICAL_AND     reduce using rule 84 (seen_arch -> .)
    LOGICAL_OR      reduce using rule 84 (seen_arch -> .)
    RP              reduce using rule 84 (seen_arch -> .)

    seen_arch                      shift and go to state 75

state 66

    (81) assignment_expr -> lhs assign array_access . seen_array
    (85) seen_array -> .

    SEMICOLON       reduce using rule 85 (seen_array -> .)
    COMMA           reduce using rule 85 (seen_array -> .)
    GR              reduce using rule 85 (seen_array -> .)
    LS              reduce using rule 85 (seen_array -> .)
    EQ              reduce using rule 85 (seen_array -> .)
    NOT_EQ          reduce using rule 85 (seen_array -> .)
    GR_EQ           reduce using rule 85 (seen_array -> .)
    LS_EQ           reduce using rule 85 (seen_array -> .)
    LOGICAL_AND     reduce using rule 85 (seen_array -> .)
    LOGICAL_OR      reduce using rule 85 (seen_array -> .)
    RP              reduce using rule 85 (seen_array -> .)

    seen_array                     shift and go to state 81

state 67

    (82) assignment_expr -> lhs assign function_call . seen_func_call
    (86) seen_func_call -> .

    SEMICOLON       reduce using rule 86 (seen_func_call -> .)
    COMMA           reduce using rule 86 (seen_func_call -> .)
    GR              reduce using rule 86 (seen_func_call -> .)
    LS              reduce using rule 86 (seen_func_call -> .)
    EQ              reduce using rule 86 (seen_func_call -> .)
    NOT_EQ          reduce using rule 86 (seen_func_call -> .)
    GR_EQ           reduce using rule 86 (seen_func_call -> .)
    LS_EQ           reduce using rule 86 (seen_func_call -> .)
    LOGICAL_AND     reduce using rule 86 (seen_func_call -> .)
    LOGICAL_OR      reduce using rule 86 (seen_func_call -> .)
    RP              reduce using rule 86 (seen_func_call -> .)

    seen_func_call                 shift and go to state 82

state 68

    (83) assignment_expr -> lhs assign unary_expr . seen_unary
    (87) seen_unary -> .

    SEMICOLON       reduce using rule 87 (seen_unary -> .)
    COMMA           reduce using rule 87 (seen_unary -> .)
    GR              reduce using rule 87 (seen_unary -> .)
    LS              reduce using rule 87 (seen_unary -> .)
    EQ              reduce using rule 87 (seen_unary -> .)
    NOT_EQ          reduce using rule 87 (seen_unary -> .)
    GR_EQ           reduce using rule 87 (seen_unary -> .)
    LS_EQ           reduce using rule 87 (seen_unary -> .)
    LOGICAL_AND     reduce using rule 87 (seen_unary -> .)
    LOGICAL_OR      reduce using rule 87 (seen_unary -> .)
    RP              reduce using rule 87 (seen_unary -> .)

    seen_unary                     shift and go to state 83

state 69

    (108) arithmetic_expr -> SUB . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 84
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 70

    (107) arithmetic_expr -> LP . arithmetic_expr RP
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 86
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 71

    (109) arithmetic_expr -> identifier .
    (115) array_access -> identifier . MLP array_index MRP
    (118) function_call -> identifier . LP parameter_list RP
    (119) function_call -> identifier . LP RP
    (88) unary_expr -> identifier . INCREMENT
    (89) unary_expr -> identifier . DECREMENT

    ADD             reduce using rule 109 (arithmetic_expr -> identifier .)
    SUB             reduce using rule 109 (arithmetic_expr -> identifier .)
    MUL             reduce using rule 109 (arithmetic_expr -> identifier .)
    DIV             reduce using rule 109 (arithmetic_expr -> identifier .)
    MOD             reduce using rule 109 (arithmetic_expr -> identifier .)
    SEMICOLON       reduce using rule 109 (arithmetic_expr -> identifier .)
    COMMA           reduce using rule 109 (arithmetic_expr -> identifier .)
    GR              reduce using rule 109 (arithmetic_expr -> identifier .)
    LS              reduce using rule 109 (arithmetic_expr -> identifier .)
    EQ              reduce using rule 109 (arithmetic_expr -> identifier .)
    NOT_EQ          reduce using rule 109 (arithmetic_expr -> identifier .)
    GR_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LS_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_AND     reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_OR      reduce using rule 109 (arithmetic_expr -> identifier .)
    RP              reduce using rule 109 (arithmetic_expr -> identifier .)
    MLP             shift and go to state 34
    LP              shift and go to state 87
    INCREMENT       shift and go to state 32
    DECREMENT       shift and go to state 33


state 72

    (110) arithmetic_expr -> constant .

    ADD             reduce using rule 110 (arithmetic_expr -> constant .)
    SUB             reduce using rule 110 (arithmetic_expr -> constant .)
    MUL             reduce using rule 110 (arithmetic_expr -> constant .)
    DIV             reduce using rule 110 (arithmetic_expr -> constant .)
    MOD             reduce using rule 110 (arithmetic_expr -> constant .)
    SEMICOLON       reduce using rule 110 (arithmetic_expr -> constant .)
    COMMA           reduce using rule 110 (arithmetic_expr -> constant .)
    GR              reduce using rule 110 (arithmetic_expr -> constant .)
    LS              reduce using rule 110 (arithmetic_expr -> constant .)
    EQ              reduce using rule 110 (arithmetic_expr -> constant .)
    NOT_EQ          reduce using rule 110 (arithmetic_expr -> constant .)
    GR_EQ           reduce using rule 110 (arithmetic_expr -> constant .)
    LS_EQ           reduce using rule 110 (arithmetic_expr -> constant .)
    LOGICAL_AND     reduce using rule 110 (arithmetic_expr -> constant .)
    LOGICAL_OR      reduce using rule 110 (arithmetic_expr -> constant .)
    RP              reduce using rule 110 (arithmetic_expr -> constant .)


state 73

    (5) function -> type identifier seen_identifier LP . argument_list seen_argument_list RP compound_stmt
    (27) argument_list -> . arguments
    (28) argument_list -> .
    (29) arguments -> . arguments COMMA arg
    (30) arguments -> . arg
    (31) arg -> . type identifier
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR

    RP              reduce using rule 28 (argument_list -> .)
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    type                           shift and go to state 88
    argument_list                  shift and go to state 89
    arguments                      shift and go to state 90
    arg                            shift and go to state 91
    data_type                      shift and go to state 9
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14

state 74

    (115) array_access -> identifier MLP array_index MRP .

    SEMICOLON       reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    COMMA           reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    ASSIGN          reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    ADD_ASSIGN      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    SUB_ASSIGN      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    DIV_ASSIGN      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    MOD_ASSIGN      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    MUL_ASSIGN      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    GR              reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    LS              reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    EQ              reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    NOT_EQ          reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    GR_EQ           reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    LS_EQ           reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    LOGICAL_AND     reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    LOGICAL_OR      reduce using rule 115 (array_access -> identifier MLP array_index MRP .)
    RP              reduce using rule 115 (array_access -> identifier MLP array_index MRP .)


state 75

    (80) assignment_expr -> lhs assign arithmetic_expr seen_arch .

    SEMICOLON       reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    COMMA           reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    GR              reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    LS              reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    EQ              reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    NOT_EQ          reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    GR_EQ           reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    LS_EQ           reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    LOGICAL_AND     reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    LOGICAL_OR      reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)
    RP              reduce using rule 80 (assignment_expr -> lhs assign arithmetic_expr seen_arch .)


state 76

    (102) arithmetic_expr -> arithmetic_expr ADD . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 92
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 77

    (103) arithmetic_expr -> arithmetic_expr SUB . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 93
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 78

    (104) arithmetic_expr -> arithmetic_expr MUL . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 94
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 79

    (105) arithmetic_expr -> arithmetic_expr DIV . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 95
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 80

    (106) arithmetic_expr -> arithmetic_expr MOD . arithmetic_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT

    LP              shift and go to state 70
    SUB             shift and go to state 69
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    arithmetic_expr                shift and go to state 96
    identifier                     shift and go to state 85
    constant                       shift and go to state 72

state 81

    (81) assignment_expr -> lhs assign array_access seen_array .

    SEMICOLON       reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    COMMA           reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    GR              reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    LS              reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    EQ              reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    NOT_EQ          reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    GR_EQ           reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    LS_EQ           reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    LOGICAL_AND     reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    LOGICAL_OR      reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)
    RP              reduce using rule 81 (assignment_expr -> lhs assign array_access seen_array .)


state 82

    (82) assignment_expr -> lhs assign function_call seen_func_call .

    SEMICOLON       reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    COMMA           reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    GR              reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    LS              reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    EQ              reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    NOT_EQ          reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    GR_EQ           reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    LS_EQ           reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    LOGICAL_AND     reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    LOGICAL_OR      reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)
    RP              reduce using rule 82 (assignment_expr -> lhs assign function_call seen_func_call .)


state 83

    (83) assignment_expr -> lhs assign unary_expr seen_unary .

    SEMICOLON       reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    COMMA           reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    GR              reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    LS              reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    EQ              reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    NOT_EQ          reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    GR_EQ           reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    LS_EQ           reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    LOGICAL_AND     reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    LOGICAL_OR      reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)
    RP              reduce using rule 83 (assignment_expr -> lhs assign unary_expr seen_unary .)


state 84

    (108) arithmetic_expr -> SUB arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    SUB             reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    SEMICOLON       reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    COMMA           reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    GR              reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    LS              reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    EQ              reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    NOT_EQ          reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    GR_EQ           reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    LS_EQ           reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    LOGICAL_AND     reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    LOGICAL_OR      reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    RP              reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .)
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80

  ! MUL             [ reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .) ]
  ! DIV             [ reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .) ]
  ! MOD             [ reduce using rule 108 (arithmetic_expr -> SUB arithmetic_expr .) ]
  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]


state 85

    (109) arithmetic_expr -> identifier .

    ADD             reduce using rule 109 (arithmetic_expr -> identifier .)
    SUB             reduce using rule 109 (arithmetic_expr -> identifier .)
    MUL             reduce using rule 109 (arithmetic_expr -> identifier .)
    DIV             reduce using rule 109 (arithmetic_expr -> identifier .)
    MOD             reduce using rule 109 (arithmetic_expr -> identifier .)
    SEMICOLON       reduce using rule 109 (arithmetic_expr -> identifier .)
    COMMA           reduce using rule 109 (arithmetic_expr -> identifier .)
    GR              reduce using rule 109 (arithmetic_expr -> identifier .)
    LS              reduce using rule 109 (arithmetic_expr -> identifier .)
    EQ              reduce using rule 109 (arithmetic_expr -> identifier .)
    NOT_EQ          reduce using rule 109 (arithmetic_expr -> identifier .)
    GR_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LS_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_AND     reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_OR      reduce using rule 109 (arithmetic_expr -> identifier .)
    RP              reduce using rule 109 (arithmetic_expr -> identifier .)


state 86

    (107) arithmetic_expr -> LP arithmetic_expr . RP
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    RP              shift and go to state 97
    ADD             shift and go to state 76
    SUB             shift and go to state 77
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80


state 87

    (118) function_call -> identifier LP . parameter_list RP
    (119) function_call -> identifier LP . RP
    (122) parameter_list -> . parameter_list COMMA parameter
    (123) parameter_list -> . parameter
    (124) parameter -> . sub_expr
    (125) parameter -> . STRING
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    RP              shift and go to state 100
    STRING          shift and go to state 103
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    identifier                     shift and go to state 98
    parameter_list                 shift and go to state 99
    parameter                      shift and go to state 101
    sub_expr                       shift and go to state 102
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 88

    (31) arg -> type . identifier
    (95) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 17

    identifier                     shift and go to state 109

state 89

    (5) function -> type identifier seen_identifier LP argument_list . seen_argument_list RP compound_stmt
    (7) seen_argument_list -> .

    RP              reduce using rule 7 (seen_argument_list -> .)

    seen_argument_list             shift and go to state 110

state 90

    (27) argument_list -> arguments .
    (29) arguments -> arguments . COMMA arg

    RP              reduce using rule 27 (argument_list -> arguments .)
    COMMA           shift and go to state 111


state 91

    (30) arguments -> arg .

    COMMA           reduce using rule 30 (arguments -> arg .)
    RP              reduce using rule 30 (arguments -> arg .)


state 92

    (102) arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    SUB             reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    SEMICOLON       reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    COMMA           reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    GR              reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    LS              reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    EQ              reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    NOT_EQ          reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    GR_EQ           reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    LS_EQ           reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    LOGICAL_AND     reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    LOGICAL_OR      reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    RP              reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .)
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80

  ! MUL             [ reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .) ]
  ! DIV             [ reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .) ]
  ! MOD             [ reduce using rule 102 (arithmetic_expr -> arithmetic_expr ADD arithmetic_expr .) ]
  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]


state 93

    (103) arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    SUB             reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    SEMICOLON       reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    COMMA           reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    GR              reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    LS              reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    EQ              reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    NOT_EQ          reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    GR_EQ           reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    LS_EQ           reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    LOGICAL_AND     reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    LOGICAL_OR      reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    RP              reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .)
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80

  ! MUL             [ reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .) ]
  ! DIV             [ reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .) ]
  ! MOD             [ reduce using rule 103 (arithmetic_expr -> arithmetic_expr SUB arithmetic_expr .) ]
  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]


state 94

    (104) arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    SUB             reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    MUL             reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    DIV             reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    MOD             reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    SEMICOLON       reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    COMMA           reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    GR              reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    LS              reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    EQ              reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    NOT_EQ          reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    GR_EQ           reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    LS_EQ           reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    LOGICAL_AND     reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    LOGICAL_OR      reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)
    RP              reduce using rule 104 (arithmetic_expr -> arithmetic_expr MUL arithmetic_expr .)

  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]
  ! MUL             [ shift and go to state 78 ]
  ! DIV             [ shift and go to state 79 ]
  ! MOD             [ shift and go to state 80 ]


state 95

    (105) arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    SUB             reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    MUL             reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    DIV             reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    MOD             reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    SEMICOLON       reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    COMMA           reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    GR              reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    LS              reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    EQ              reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    NOT_EQ          reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    GR_EQ           reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    LS_EQ           reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    LOGICAL_AND     reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    LOGICAL_OR      reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)
    RP              reduce using rule 105 (arithmetic_expr -> arithmetic_expr DIV arithmetic_expr .)

  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]
  ! MUL             [ shift and go to state 78 ]
  ! DIV             [ shift and go to state 79 ]
  ! MOD             [ shift and go to state 80 ]


state 96

    (106) arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr

    ADD             reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    SUB             reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    MUL             reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    DIV             reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    MOD             reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    SEMICOLON       reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    COMMA           reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    GR              reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    LS              reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    EQ              reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    NOT_EQ          reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    GR_EQ           reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    LS_EQ           reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    LOGICAL_AND     reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    LOGICAL_OR      reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)
    RP              reduce using rule 106 (arithmetic_expr -> arithmetic_expr MOD arithmetic_expr .)

  ! ADD             [ shift and go to state 76 ]
  ! SUB             [ shift and go to state 77 ]
  ! MUL             [ shift and go to state 78 ]
  ! DIV             [ shift and go to state 79 ]
  ! MOD             [ shift and go to state 80 ]


state 97

    (107) arithmetic_expr -> LP arithmetic_expr RP .

    ADD             reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    SUB             reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    MUL             reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    DIV             reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    MOD             reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    SEMICOLON       reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    COMMA           reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    GR              reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    LS              reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    EQ              reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    NOT_EQ          reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    GR_EQ           reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    LS_EQ           reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    LOGICAL_AND     reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    LOGICAL_OR      reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)
    RP              reduce using rule 107 (arithmetic_expr -> LP arithmetic_expr RP .)


state 98

    (109) arithmetic_expr -> identifier .
    (88) unary_expr -> identifier . INCREMENT
    (89) unary_expr -> identifier . DECREMENT
    (92) lhs -> identifier . seen_id
    (115) array_access -> identifier . MLP array_index MRP
    (94) seen_id -> .

    ADD             reduce using rule 109 (arithmetic_expr -> identifier .)
    SUB             reduce using rule 109 (arithmetic_expr -> identifier .)
    MUL             reduce using rule 109 (arithmetic_expr -> identifier .)
    DIV             reduce using rule 109 (arithmetic_expr -> identifier .)
    MOD             reduce using rule 109 (arithmetic_expr -> identifier .)
    GR              reduce using rule 109 (arithmetic_expr -> identifier .)
    LS              reduce using rule 109 (arithmetic_expr -> identifier .)
    EQ              reduce using rule 109 (arithmetic_expr -> identifier .)
    NOT_EQ          reduce using rule 109 (arithmetic_expr -> identifier .)
    GR_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LS_EQ           reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_AND     reduce using rule 109 (arithmetic_expr -> identifier .)
    LOGICAL_OR      reduce using rule 109 (arithmetic_expr -> identifier .)
    RP              reduce using rule 109 (arithmetic_expr -> identifier .)
    COMMA           reduce using rule 109 (arithmetic_expr -> identifier .)
    SEMICOLON       reduce using rule 109 (arithmetic_expr -> identifier .)
    INCREMENT       shift and go to state 32
    DECREMENT       shift and go to state 33
    MLP             shift and go to state 34
    ASSIGN          reduce using rule 94 (seen_id -> .)
    ADD_ASSIGN      reduce using rule 94 (seen_id -> .)
    SUB_ASSIGN      reduce using rule 94 (seen_id -> .)
    DIV_ASSIGN      reduce using rule 94 (seen_id -> .)
    MOD_ASSIGN      reduce using rule 94 (seen_id -> .)
    MUL_ASSIGN      reduce using rule 94 (seen_id -> .)

    seen_id                        shift and go to state 35

state 99

    (118) function_call -> identifier LP parameter_list . RP
    (122) parameter_list -> parameter_list . COMMA parameter

    RP              shift and go to state 112
    COMMA           shift and go to state 113


state 100

    (119) function_call -> identifier LP RP .

    SEMICOLON       reduce using rule 119 (function_call -> identifier LP RP .)
    COMMA           reduce using rule 119 (function_call -> identifier LP RP .)
    GR              reduce using rule 119 (function_call -> identifier LP RP .)
    LS              reduce using rule 119 (function_call -> identifier LP RP .)
    EQ              reduce using rule 119 (function_call -> identifier LP RP .)
    NOT_EQ          reduce using rule 119 (function_call -> identifier LP RP .)
    GR_EQ           reduce using rule 119 (function_call -> identifier LP RP .)
    LS_EQ           reduce using rule 119 (function_call -> identifier LP RP .)
    LOGICAL_AND     reduce using rule 119 (function_call -> identifier LP RP .)
    LOGICAL_OR      reduce using rule 119 (function_call -> identifier LP RP .)
    RP              reduce using rule 119 (function_call -> identifier LP RP .)


state 101

    (123) parameter_list -> parameter .

    RP              reduce using rule 123 (parameter_list -> parameter .)
    COMMA           reduce using rule 123 (parameter_list -> parameter .)


state 102

    (124) parameter -> sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    RP              reduce using rule 124 (parameter -> sub_expr .)
    COMMA           reduce using rule 124 (parameter -> sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119
    LOGICAL_AND     shift and go to state 120
    LOGICAL_OR      shift and go to state 121


state 103

    (125) parameter -> STRING .

    RP              reduce using rule 125 (parameter -> STRING .)
    COMMA           reduce using rule 125 (parameter -> STRING .)


state 104

    (75) sub_expr -> NOT . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 122
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 105

    (76) sub_expr -> arithmetic_expr . seen_arith
    (102) arithmetic_expr -> arithmetic_expr . ADD arithmetic_expr
    (103) arithmetic_expr -> arithmetic_expr . SUB arithmetic_expr
    (104) arithmetic_expr -> arithmetic_expr . MUL arithmetic_expr
    (105) arithmetic_expr -> arithmetic_expr . DIV arithmetic_expr
    (106) arithmetic_expr -> arithmetic_expr . MOD arithmetic_expr
    (79) seen_arith -> .

    ADD             shift and go to state 76
    SUB             shift and go to state 77
    MUL             shift and go to state 78
    DIV             shift and go to state 79
    MOD             shift and go to state 80
    GR              reduce using rule 79 (seen_arith -> .)
    LS              reduce using rule 79 (seen_arith -> .)
    EQ              reduce using rule 79 (seen_arith -> .)
    NOT_EQ          reduce using rule 79 (seen_arith -> .)
    GR_EQ           reduce using rule 79 (seen_arith -> .)
    LS_EQ           reduce using rule 79 (seen_arith -> .)
    LOGICAL_AND     reduce using rule 79 (seen_arith -> .)
    LOGICAL_OR      reduce using rule 79 (seen_arith -> .)
    RP              reduce using rule 79 (seen_arith -> .)
    COMMA           reduce using rule 79 (seen_arith -> .)
    SEMICOLON       reduce using rule 79 (seen_arith -> .)

    seen_arith                     shift and go to state 123

state 106

    (77) sub_expr -> assignment_expr .

    GR              reduce using rule 77 (sub_expr -> assignment_expr .)
    LS              reduce using rule 77 (sub_expr -> assignment_expr .)
    EQ              reduce using rule 77 (sub_expr -> assignment_expr .)
    NOT_EQ          reduce using rule 77 (sub_expr -> assignment_expr .)
    GR_EQ           reduce using rule 77 (sub_expr -> assignment_expr .)
    LS_EQ           reduce using rule 77 (sub_expr -> assignment_expr .)
    LOGICAL_AND     reduce using rule 77 (sub_expr -> assignment_expr .)
    LOGICAL_OR      reduce using rule 77 (sub_expr -> assignment_expr .)
    RP              reduce using rule 77 (sub_expr -> assignment_expr .)
    COMMA           reduce using rule 77 (sub_expr -> assignment_expr .)
    SEMICOLON       reduce using rule 77 (sub_expr -> assignment_expr .)


state 107

    (78) sub_expr -> unary_expr .

    GR              reduce using rule 78 (sub_expr -> unary_expr .)
    LS              reduce using rule 78 (sub_expr -> unary_expr .)
    EQ              reduce using rule 78 (sub_expr -> unary_expr .)
    NOT_EQ          reduce using rule 78 (sub_expr -> unary_expr .)
    GR_EQ           reduce using rule 78 (sub_expr -> unary_expr .)
    LS_EQ           reduce using rule 78 (sub_expr -> unary_expr .)
    LOGICAL_AND     reduce using rule 78 (sub_expr -> unary_expr .)
    LOGICAL_OR      reduce using rule 78 (sub_expr -> unary_expr .)
    RP              reduce using rule 78 (sub_expr -> unary_expr .)
    COMMA           reduce using rule 78 (sub_expr -> unary_expr .)
    SEMICOLON       reduce using rule 78 (sub_expr -> unary_expr .)


state 108

    (93) lhs -> array_access .

    ASSIGN          reduce using rule 93 (lhs -> array_access .)
    ADD_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    SUB_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    DIV_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    MOD_ASSIGN      reduce using rule 93 (lhs -> array_access .)
    MUL_ASSIGN      reduce using rule 93 (lhs -> array_access .)


state 109

    (31) arg -> type identifier .

    COMMA           reduce using rule 31 (arg -> type identifier .)
    RP              reduce using rule 31 (arg -> type identifier .)


state 110

    (5) function -> type identifier seen_identifier LP argument_list seen_argument_list . RP compound_stmt

    RP              shift and go to state 124


state 111

    (29) arguments -> arguments COMMA . arg
    (31) arg -> . type identifier
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR

    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    arg                            shift and go to state 125
    type                           shift and go to state 88
    data_type                      shift and go to state 9
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14

state 112

    (118) function_call -> identifier LP parameter_list RP .

    SEMICOLON       reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    COMMA           reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    GR              reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    LS              reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    EQ              reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    NOT_EQ          reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    GR_EQ           reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    LS_EQ           reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    LOGICAL_AND     reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    LOGICAL_OR      reduce using rule 118 (function_call -> identifier LP parameter_list RP .)
    RP              reduce using rule 118 (function_call -> identifier LP parameter_list RP .)


state 113

    (122) parameter_list -> parameter_list COMMA . parameter
    (124) parameter -> . sub_expr
    (125) parameter -> . STRING
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    STRING          shift and go to state 103
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    parameter                      shift and go to state 126
    sub_expr                       shift and go to state 102
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 114

    (67) sub_expr -> sub_expr GR . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 127
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 115

    (68) sub_expr -> sub_expr LS . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 128
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 116

    (69) sub_expr -> sub_expr EQ . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 129
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 117

    (70) sub_expr -> sub_expr NOT_EQ . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 130
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 118

    (71) sub_expr -> sub_expr GR_EQ . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 131
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 119

    (72) sub_expr -> sub_expr LS_EQ . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 132
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 120

    (73) sub_expr -> sub_expr LOGICAL_AND . M sub_expr
    (126) M -> .

    NOT             reduce using rule 126 (M -> .)
    LP              reduce using rule 126 (M -> .)
    SUB             reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    DEC_CONSTANT    reduce using rule 126 (M -> .)
    HEX_CONSTANT    reduce using rule 126 (M -> .)
    CHAR_CONSTANT   reduce using rule 126 (M -> .)
    FLOAT_CONSTANT  reduce using rule 126 (M -> .)

    M                              shift and go to state 133

state 121

    (74) sub_expr -> sub_expr LOGICAL_OR . M sub_expr
    (126) M -> .

    NOT             reduce using rule 126 (M -> .)
    LP              reduce using rule 126 (M -> .)
    SUB             reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    DEC_CONSTANT    reduce using rule 126 (M -> .)
    HEX_CONSTANT    reduce using rule 126 (M -> .)
    CHAR_CONSTANT   reduce using rule 126 (M -> .)
    FLOAT_CONSTANT  reduce using rule 126 (M -> .)

    M                              shift and go to state 134

state 122

    (75) sub_expr -> NOT sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    GR              reduce using rule 75 (sub_expr -> NOT sub_expr .)
    LS              reduce using rule 75 (sub_expr -> NOT sub_expr .)
    EQ              reduce using rule 75 (sub_expr -> NOT sub_expr .)
    NOT_EQ          reduce using rule 75 (sub_expr -> NOT sub_expr .)
    GR_EQ           reduce using rule 75 (sub_expr -> NOT sub_expr .)
    LS_EQ           reduce using rule 75 (sub_expr -> NOT sub_expr .)
    LOGICAL_AND     reduce using rule 75 (sub_expr -> NOT sub_expr .)
    LOGICAL_OR      reduce using rule 75 (sub_expr -> NOT sub_expr .)
    RP              reduce using rule 75 (sub_expr -> NOT sub_expr .)
    COMMA           reduce using rule 75 (sub_expr -> NOT sub_expr .)
    SEMICOLON       reduce using rule 75 (sub_expr -> NOT sub_expr .)

  ! GR              [ shift and go to state 114 ]
  ! LS              [ shift and go to state 115 ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! GR_EQ           [ shift and go to state 118 ]
  ! LS_EQ           [ shift and go to state 119 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 123

    (76) sub_expr -> arithmetic_expr seen_arith .

    GR              reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    LS              reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    EQ              reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    NOT_EQ          reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    GR_EQ           reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    LS_EQ           reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    LOGICAL_AND     reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    LOGICAL_OR      reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    RP              reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    COMMA           reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)
    SEMICOLON       reduce using rule 76 (sub_expr -> arithmetic_expr seen_arith .)


state 124

    (5) function -> type identifier seen_identifier LP argument_list seen_argument_list RP . compound_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP

    BLP             shift and go to state 136

    compound_stmt                  shift and go to state 135

state 125

    (29) arguments -> arguments COMMA arg .

    COMMA           reduce using rule 29 (arguments -> arguments COMMA arg .)
    RP              reduce using rule 29 (arguments -> arguments COMMA arg .)


state 126

    (122) parameter_list -> parameter_list COMMA parameter .

    RP              reduce using rule 122 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 122 (parameter_list -> parameter_list COMMA parameter .)


state 127

    (67) sub_expr -> sub_expr GR sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    GR              reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    LS              reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    EQ              reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    NOT_EQ          reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    GR_EQ           reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    LS_EQ           reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    LOGICAL_AND     reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    LOGICAL_OR      reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    RP              reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    COMMA           reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)
    SEMICOLON       reduce using rule 67 (sub_expr -> sub_expr GR sub_expr .)

  ! GR              [ shift and go to state 114 ]
  ! LS              [ shift and go to state 115 ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! GR_EQ           [ shift and go to state 118 ]
  ! LS_EQ           [ shift and go to state 119 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 128

    (68) sub_expr -> sub_expr LS sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    GR              reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    LS              reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    EQ              reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    NOT_EQ          reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    GR_EQ           reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    LS_EQ           reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    LOGICAL_AND     reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    LOGICAL_OR      reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    RP              reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    COMMA           reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)
    SEMICOLON       reduce using rule 68 (sub_expr -> sub_expr LS sub_expr .)

  ! GR              [ shift and go to state 114 ]
  ! LS              [ shift and go to state 115 ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! GR_EQ           [ shift and go to state 118 ]
  ! LS_EQ           [ shift and go to state 119 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 129

    (69) sub_expr -> sub_expr EQ sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    EQ              reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    NOT_EQ          reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    LOGICAL_AND     reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    LOGICAL_OR      reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    RP              reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    COMMA           reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    SEMICOLON       reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119

  ! GR              [ reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .) ]
  ! LS              [ reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .) ]
  ! GR_EQ           [ reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .) ]
  ! LS_EQ           [ reduce using rule 69 (sub_expr -> sub_expr EQ sub_expr .) ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 130

    (70) sub_expr -> sub_expr NOT_EQ sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    EQ              reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    NOT_EQ          reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    LOGICAL_AND     reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    LOGICAL_OR      reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    RP              reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    COMMA           reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    SEMICOLON       reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119

  ! GR              [ reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .) ]
  ! LS              [ reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .) ]
  ! GR_EQ           [ reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .) ]
  ! LS_EQ           [ reduce using rule 70 (sub_expr -> sub_expr NOT_EQ sub_expr .) ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 131

    (71) sub_expr -> sub_expr GR_EQ sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    GR              reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    LS              reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    EQ              reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    NOT_EQ          reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    GR_EQ           reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    LS_EQ           reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    LOGICAL_AND     reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    LOGICAL_OR      reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    RP              reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    COMMA           reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)
    SEMICOLON       reduce using rule 71 (sub_expr -> sub_expr GR_EQ sub_expr .)

  ! GR              [ shift and go to state 114 ]
  ! LS              [ shift and go to state 115 ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! GR_EQ           [ shift and go to state 118 ]
  ! LS_EQ           [ shift and go to state 119 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 132

    (72) sub_expr -> sub_expr LS_EQ sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    GR              reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    LS              reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    EQ              reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    NOT_EQ          reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    GR_EQ           reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    LS_EQ           reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    LOGICAL_AND     reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    LOGICAL_OR      reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    RP              reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    COMMA           reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)
    SEMICOLON       reduce using rule 72 (sub_expr -> sub_expr LS_EQ sub_expr .)

  ! GR              [ shift and go to state 114 ]
  ! LS              [ shift and go to state 115 ]
  ! EQ              [ shift and go to state 116 ]
  ! NOT_EQ          [ shift and go to state 117 ]
  ! GR_EQ           [ shift and go to state 118 ]
  ! LS_EQ           [ shift and go to state 119 ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 133

    (73) sub_expr -> sub_expr LOGICAL_AND M . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 137
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 134

    (74) sub_expr -> sub_expr LOGICAL_OR M . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 138
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 135

    (5) function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .

    DECREMENT       reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    INCREMENT       reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    IDENTIFIER      reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    SIGNED          reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    UNSIGNED        reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    INT             reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    SHORT           reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    LONG            reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    LONG_LONG       reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    CHAR            reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    FLOAT           reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    VOID            reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    CHAR_STAR       reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)
    $end            reduce using rule 5 (function -> type identifier seen_identifier LP argument_list seen_argument_list RP compound_stmt .)


state 136

    (34) compound_stmt -> BLP . seen_BLP statements BRP
    (35) seen_BLP -> .

    BRP             reduce using rule 35 (seen_BLP -> .)
    BLP             reduce using rule 35 (seen_BLP -> .)
    RETURN          reduce using rule 35 (seen_BLP -> .)
    CONTINUE        reduce using rule 35 (seen_BLP -> .)
    BREAK           reduce using rule 35 (seen_BLP -> .)
    IF              reduce using rule 35 (seen_BLP -> .)
    FOR             reduce using rule 35 (seen_BLP -> .)
    WHILE           reduce using rule 35 (seen_BLP -> .)
    PRNTF           reduce using rule 35 (seen_BLP -> .)
    DECREMENT       reduce using rule 35 (seen_BLP -> .)
    INCREMENT       reduce using rule 35 (seen_BLP -> .)
    IDENTIFIER      reduce using rule 35 (seen_BLP -> .)
    SIGNED          reduce using rule 35 (seen_BLP -> .)
    UNSIGNED        reduce using rule 35 (seen_BLP -> .)
    INT             reduce using rule 35 (seen_BLP -> .)
    SHORT           reduce using rule 35 (seen_BLP -> .)
    LONG            reduce using rule 35 (seen_BLP -> .)
    LONG_LONG       reduce using rule 35 (seen_BLP -> .)
    CHAR            reduce using rule 35 (seen_BLP -> .)
    FLOAT           reduce using rule 35 (seen_BLP -> .)
    VOID            reduce using rule 35 (seen_BLP -> .)
    CHAR_STAR       reduce using rule 35 (seen_BLP -> .)

    seen_BLP                       shift and go to state 139

state 137

    (73) sub_expr -> sub_expr LOGICAL_AND M sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    LOGICAL_AND     reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .)
    LOGICAL_OR      reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .)
    RP              reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .)
    COMMA           reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .)
    SEMICOLON       reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119

  ! GR              [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! LS              [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! EQ              [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! NOT_EQ          [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! GR_EQ           [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! LS_EQ           [ reduce using rule 73 (sub_expr -> sub_expr LOGICAL_AND M sub_expr .) ]
  ! LOGICAL_AND     [ shift and go to state 120 ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 138

    (74) sub_expr -> sub_expr LOGICAL_OR M sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    LOGICAL_OR      reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .)
    RP              reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .)
    COMMA           reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .)
    SEMICOLON       reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119
    LOGICAL_AND     shift and go to state 120

  ! GR              [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! LS              [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! EQ              [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! NOT_EQ          [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! GR_EQ           [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! LS_EQ           [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! LOGICAL_AND     [ reduce using rule 74 (sub_expr -> sub_expr LOGICAL_OR M sub_expr .) ]
  ! LOGICAL_OR      [ shift and go to state 121 ]


state 139

    (34) compound_stmt -> BLP seen_BLP . statements BRP
    (36) statements -> . statements M stmt
    (37) statements -> .

    BRP             reduce using rule 37 (statements -> .)
    BLP             reduce using rule 37 (statements -> .)
    RETURN          reduce using rule 37 (statements -> .)
    CONTINUE        reduce using rule 37 (statements -> .)
    BREAK           reduce using rule 37 (statements -> .)
    IF              reduce using rule 37 (statements -> .)
    FOR             reduce using rule 37 (statements -> .)
    WHILE           reduce using rule 37 (statements -> .)
    PRNTF           reduce using rule 37 (statements -> .)
    DECREMENT       reduce using rule 37 (statements -> .)
    INCREMENT       reduce using rule 37 (statements -> .)
    IDENTIFIER      reduce using rule 37 (statements -> .)
    SIGNED          reduce using rule 37 (statements -> .)
    UNSIGNED        reduce using rule 37 (statements -> .)
    INT             reduce using rule 37 (statements -> .)
    SHORT           reduce using rule 37 (statements -> .)
    LONG            reduce using rule 37 (statements -> .)
    LONG_LONG       reduce using rule 37 (statements -> .)
    CHAR            reduce using rule 37 (statements -> .)
    FLOAT           reduce using rule 37 (statements -> .)
    VOID            reduce using rule 37 (statements -> .)
    CHAR_STAR       reduce using rule 37 (statements -> .)

    statements                     shift and go to state 140

state 140

    (34) compound_stmt -> BLP seen_BLP statements . BRP
    (36) statements -> statements . M stmt
    (126) M -> .

    BRP             shift and go to state 141
    BLP             reduce using rule 126 (M -> .)
    RETURN          reduce using rule 126 (M -> .)
    CONTINUE        reduce using rule 126 (M -> .)
    BREAK           reduce using rule 126 (M -> .)
    IF              reduce using rule 126 (M -> .)
    FOR             reduce using rule 126 (M -> .)
    WHILE           reduce using rule 126 (M -> .)
    PRNTF           reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    SIGNED          reduce using rule 126 (M -> .)
    UNSIGNED        reduce using rule 126 (M -> .)
    INT             reduce using rule 126 (M -> .)
    SHORT           reduce using rule 126 (M -> .)
    LONG            reduce using rule 126 (M -> .)
    LONG_LONG       reduce using rule 126 (M -> .)
    CHAR            reduce using rule 126 (M -> .)
    FLOAT           reduce using rule 126 (M -> .)
    VOID            reduce using rule 126 (M -> .)
    CHAR_STAR       reduce using rule 126 (M -> .)

    M                              shift and go to state 142

state 141

    (34) compound_stmt -> BLP seen_BLP statements BRP .

    DECREMENT       reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    INCREMENT       reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    IDENTIFIER      reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    SIGNED          reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    UNSIGNED        reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    INT             reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    SHORT           reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    LONG            reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    LONG_LONG       reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    CHAR            reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    FLOAT           reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    VOID            reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    CHAR_STAR       reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    $end            reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    BRP             reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    BLP             reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    RETURN          reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    CONTINUE        reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    BREAK           reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    IF              reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    FOR             reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    WHILE           reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    PRNTF           reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)
    ELSE            reduce using rule 34 (compound_stmt -> BLP seen_BLP statements BRP .)


state 142

    (36) statements -> statements M . stmt
    (32) stmt -> . compound_stmt
    (33) stmt -> . single_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP
    (38) single_stmt -> . if_block seen_control
    (39) single_stmt -> . for_block seen_control
    (40) single_stmt -> . while_block seen_control
    (41) single_stmt -> . declaration
    (42) single_stmt -> . function_call SEMICOLON
    (43) single_stmt -> . RETURN SEMICOLON
    (44) single_stmt -> . prntf_call SEMICOLON
    (45) single_stmt -> . RETURN sub_expr SEMICOLON
    (46) single_stmt -> . CONTINUE SEMICOLON
    (47) single_stmt -> . BREAK SEMICOLON
    (54) if_block -> . IF LP expression RP M stmt ELSE N M stmt
    (55) if_block -> . IF LP expression RP M stmt
    (51) for_block -> . FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (56) while_block -> . WHILE M LP expression RP M before_loop stmt after_loop
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (120) prntf_call -> . PRNTF LP STRING RP
    (121) prntf_call -> . PRNTF LP STRING COMMA parameter_list RP
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    BLP             shift and go to state 136
    RETURN          shift and go to state 151
    CONTINUE        shift and go to state 153
    BREAK           shift and go to state 154
    IF              shift and go to state 155
    FOR             shift and go to state 156
    WHILE           shift and go to state 157
    PRNTF           shift and go to state 160
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    stmt                           shift and go to state 143
    compound_stmt                  shift and go to state 144
    single_stmt                    shift and go to state 145
    if_block                       shift and go to state 146
    for_block                      shift and go to state 147
    while_block                    shift and go to state 148
    declaration                    shift and go to state 149
    function_call                  shift and go to state 150
    prntf_call                     shift and go to state 152
    type                           shift and go to state 158
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    identifier                     shift and go to state 159
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 143

    (36) statements -> statements M stmt .

    BRP             reduce using rule 36 (statements -> statements M stmt .)
    BLP             reduce using rule 36 (statements -> statements M stmt .)
    RETURN          reduce using rule 36 (statements -> statements M stmt .)
    CONTINUE        reduce using rule 36 (statements -> statements M stmt .)
    BREAK           reduce using rule 36 (statements -> statements M stmt .)
    IF              reduce using rule 36 (statements -> statements M stmt .)
    FOR             reduce using rule 36 (statements -> statements M stmt .)
    WHILE           reduce using rule 36 (statements -> statements M stmt .)
    PRNTF           reduce using rule 36 (statements -> statements M stmt .)
    DECREMENT       reduce using rule 36 (statements -> statements M stmt .)
    INCREMENT       reduce using rule 36 (statements -> statements M stmt .)
    IDENTIFIER      reduce using rule 36 (statements -> statements M stmt .)
    SIGNED          reduce using rule 36 (statements -> statements M stmt .)
    UNSIGNED        reduce using rule 36 (statements -> statements M stmt .)
    INT             reduce using rule 36 (statements -> statements M stmt .)
    SHORT           reduce using rule 36 (statements -> statements M stmt .)
    LONG            reduce using rule 36 (statements -> statements M stmt .)
    LONG_LONG       reduce using rule 36 (statements -> statements M stmt .)
    CHAR            reduce using rule 36 (statements -> statements M stmt .)
    FLOAT           reduce using rule 36 (statements -> statements M stmt .)
    VOID            reduce using rule 36 (statements -> statements M stmt .)
    CHAR_STAR       reduce using rule 36 (statements -> statements M stmt .)


state 144

    (32) stmt -> compound_stmt .

    BRP             reduce using rule 32 (stmt -> compound_stmt .)
    BLP             reduce using rule 32 (stmt -> compound_stmt .)
    RETURN          reduce using rule 32 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 32 (stmt -> compound_stmt .)
    BREAK           reduce using rule 32 (stmt -> compound_stmt .)
    IF              reduce using rule 32 (stmt -> compound_stmt .)
    FOR             reduce using rule 32 (stmt -> compound_stmt .)
    WHILE           reduce using rule 32 (stmt -> compound_stmt .)
    PRNTF           reduce using rule 32 (stmt -> compound_stmt .)
    DECREMENT       reduce using rule 32 (stmt -> compound_stmt .)
    INCREMENT       reduce using rule 32 (stmt -> compound_stmt .)
    IDENTIFIER      reduce using rule 32 (stmt -> compound_stmt .)
    SIGNED          reduce using rule 32 (stmt -> compound_stmt .)
    UNSIGNED        reduce using rule 32 (stmt -> compound_stmt .)
    INT             reduce using rule 32 (stmt -> compound_stmt .)
    SHORT           reduce using rule 32 (stmt -> compound_stmt .)
    LONG            reduce using rule 32 (stmt -> compound_stmt .)
    LONG_LONG       reduce using rule 32 (stmt -> compound_stmt .)
    CHAR            reduce using rule 32 (stmt -> compound_stmt .)
    FLOAT           reduce using rule 32 (stmt -> compound_stmt .)
    VOID            reduce using rule 32 (stmt -> compound_stmt .)
    CHAR_STAR       reduce using rule 32 (stmt -> compound_stmt .)
    ELSE            reduce using rule 32 (stmt -> compound_stmt .)


state 145

    (33) stmt -> single_stmt .

    BRP             reduce using rule 33 (stmt -> single_stmt .)
    BLP             reduce using rule 33 (stmt -> single_stmt .)
    RETURN          reduce using rule 33 (stmt -> single_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> single_stmt .)
    BREAK           reduce using rule 33 (stmt -> single_stmt .)
    IF              reduce using rule 33 (stmt -> single_stmt .)
    FOR             reduce using rule 33 (stmt -> single_stmt .)
    WHILE           reduce using rule 33 (stmt -> single_stmt .)
    PRNTF           reduce using rule 33 (stmt -> single_stmt .)
    DECREMENT       reduce using rule 33 (stmt -> single_stmt .)
    INCREMENT       reduce using rule 33 (stmt -> single_stmt .)
    IDENTIFIER      reduce using rule 33 (stmt -> single_stmt .)
    SIGNED          reduce using rule 33 (stmt -> single_stmt .)
    UNSIGNED        reduce using rule 33 (stmt -> single_stmt .)
    INT             reduce using rule 33 (stmt -> single_stmt .)
    SHORT           reduce using rule 33 (stmt -> single_stmt .)
    LONG            reduce using rule 33 (stmt -> single_stmt .)
    LONG_LONG       reduce using rule 33 (stmt -> single_stmt .)
    CHAR            reduce using rule 33 (stmt -> single_stmt .)
    FLOAT           reduce using rule 33 (stmt -> single_stmt .)
    VOID            reduce using rule 33 (stmt -> single_stmt .)
    CHAR_STAR       reduce using rule 33 (stmt -> single_stmt .)
    ELSE            reduce using rule 33 (stmt -> single_stmt .)


state 146

    (38) single_stmt -> if_block . seen_control
    (48) seen_control -> .

    BRP             reduce using rule 48 (seen_control -> .)
    BLP             reduce using rule 48 (seen_control -> .)
    RETURN          reduce using rule 48 (seen_control -> .)
    CONTINUE        reduce using rule 48 (seen_control -> .)
    BREAK           reduce using rule 48 (seen_control -> .)
    IF              reduce using rule 48 (seen_control -> .)
    FOR             reduce using rule 48 (seen_control -> .)
    WHILE           reduce using rule 48 (seen_control -> .)
    PRNTF           reduce using rule 48 (seen_control -> .)
    DECREMENT       reduce using rule 48 (seen_control -> .)
    INCREMENT       reduce using rule 48 (seen_control -> .)
    IDENTIFIER      reduce using rule 48 (seen_control -> .)
    SIGNED          reduce using rule 48 (seen_control -> .)
    UNSIGNED        reduce using rule 48 (seen_control -> .)
    INT             reduce using rule 48 (seen_control -> .)
    SHORT           reduce using rule 48 (seen_control -> .)
    LONG            reduce using rule 48 (seen_control -> .)
    LONG_LONG       reduce using rule 48 (seen_control -> .)
    CHAR            reduce using rule 48 (seen_control -> .)
    FLOAT           reduce using rule 48 (seen_control -> .)
    VOID            reduce using rule 48 (seen_control -> .)
    CHAR_STAR       reduce using rule 48 (seen_control -> .)
    ELSE            reduce using rule 48 (seen_control -> .)

    seen_control                   shift and go to state 161

state 147

    (39) single_stmt -> for_block . seen_control
    (48) seen_control -> .

    BRP             reduce using rule 48 (seen_control -> .)
    BLP             reduce using rule 48 (seen_control -> .)
    RETURN          reduce using rule 48 (seen_control -> .)
    CONTINUE        reduce using rule 48 (seen_control -> .)
    BREAK           reduce using rule 48 (seen_control -> .)
    IF              reduce using rule 48 (seen_control -> .)
    FOR             reduce using rule 48 (seen_control -> .)
    WHILE           reduce using rule 48 (seen_control -> .)
    PRNTF           reduce using rule 48 (seen_control -> .)
    DECREMENT       reduce using rule 48 (seen_control -> .)
    INCREMENT       reduce using rule 48 (seen_control -> .)
    IDENTIFIER      reduce using rule 48 (seen_control -> .)
    SIGNED          reduce using rule 48 (seen_control -> .)
    UNSIGNED        reduce using rule 48 (seen_control -> .)
    INT             reduce using rule 48 (seen_control -> .)
    SHORT           reduce using rule 48 (seen_control -> .)
    LONG            reduce using rule 48 (seen_control -> .)
    LONG_LONG       reduce using rule 48 (seen_control -> .)
    CHAR            reduce using rule 48 (seen_control -> .)
    FLOAT           reduce using rule 48 (seen_control -> .)
    VOID            reduce using rule 48 (seen_control -> .)
    CHAR_STAR       reduce using rule 48 (seen_control -> .)
    ELSE            reduce using rule 48 (seen_control -> .)

    seen_control                   shift and go to state 162

state 148

    (40) single_stmt -> while_block . seen_control
    (48) seen_control -> .

    BRP             reduce using rule 48 (seen_control -> .)
    BLP             reduce using rule 48 (seen_control -> .)
    RETURN          reduce using rule 48 (seen_control -> .)
    CONTINUE        reduce using rule 48 (seen_control -> .)
    BREAK           reduce using rule 48 (seen_control -> .)
    IF              reduce using rule 48 (seen_control -> .)
    FOR             reduce using rule 48 (seen_control -> .)
    WHILE           reduce using rule 48 (seen_control -> .)
    PRNTF           reduce using rule 48 (seen_control -> .)
    DECREMENT       reduce using rule 48 (seen_control -> .)
    INCREMENT       reduce using rule 48 (seen_control -> .)
    IDENTIFIER      reduce using rule 48 (seen_control -> .)
    SIGNED          reduce using rule 48 (seen_control -> .)
    UNSIGNED        reduce using rule 48 (seen_control -> .)
    INT             reduce using rule 48 (seen_control -> .)
    SHORT           reduce using rule 48 (seen_control -> .)
    LONG            reduce using rule 48 (seen_control -> .)
    LONG_LONG       reduce using rule 48 (seen_control -> .)
    CHAR            reduce using rule 48 (seen_control -> .)
    FLOAT           reduce using rule 48 (seen_control -> .)
    VOID            reduce using rule 48 (seen_control -> .)
    CHAR_STAR       reduce using rule 48 (seen_control -> .)
    ELSE            reduce using rule 48 (seen_control -> .)

    seen_control                   shift and go to state 163

state 149

    (41) single_stmt -> declaration .

    BRP             reduce using rule 41 (single_stmt -> declaration .)
    BLP             reduce using rule 41 (single_stmt -> declaration .)
    RETURN          reduce using rule 41 (single_stmt -> declaration .)
    CONTINUE        reduce using rule 41 (single_stmt -> declaration .)
    BREAK           reduce using rule 41 (single_stmt -> declaration .)
    IF              reduce using rule 41 (single_stmt -> declaration .)
    FOR             reduce using rule 41 (single_stmt -> declaration .)
    WHILE           reduce using rule 41 (single_stmt -> declaration .)
    PRNTF           reduce using rule 41 (single_stmt -> declaration .)
    DECREMENT       reduce using rule 41 (single_stmt -> declaration .)
    INCREMENT       reduce using rule 41 (single_stmt -> declaration .)
    IDENTIFIER      reduce using rule 41 (single_stmt -> declaration .)
    SIGNED          reduce using rule 41 (single_stmt -> declaration .)
    UNSIGNED        reduce using rule 41 (single_stmt -> declaration .)
    INT             reduce using rule 41 (single_stmt -> declaration .)
    SHORT           reduce using rule 41 (single_stmt -> declaration .)
    LONG            reduce using rule 41 (single_stmt -> declaration .)
    LONG_LONG       reduce using rule 41 (single_stmt -> declaration .)
    CHAR            reduce using rule 41 (single_stmt -> declaration .)
    FLOAT           reduce using rule 41 (single_stmt -> declaration .)
    VOID            reduce using rule 41 (single_stmt -> declaration .)
    CHAR_STAR       reduce using rule 41 (single_stmt -> declaration .)
    ELSE            reduce using rule 41 (single_stmt -> declaration .)


state 150

    (42) single_stmt -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 164


state 151

    (43) single_stmt -> RETURN . SEMICOLON
    (45) single_stmt -> RETURN . sub_expr SEMICOLON
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    SEMICOLON       shift and go to state 165
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 166
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 152

    (44) single_stmt -> prntf_call . SEMICOLON

    SEMICOLON       shift and go to state 167


state 153

    (46) single_stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 154

    (47) single_stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 169


state 155

    (54) if_block -> IF . LP expression RP M stmt ELSE N M stmt
    (55) if_block -> IF . LP expression RP M stmt

    LP              shift and go to state 170


state 156

    (51) for_block -> FOR . LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop

    LP              shift and go to state 171


state 157

    (56) while_block -> WHILE . M LP expression RP M before_loop stmt after_loop
    (126) M -> .

    LP              reduce using rule 126 (M -> .)

    M                              shift and go to state 172

state 158

    (57) declaration -> type . declaration_list SEMICOLON
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (95) identifier -> . IDENTIFIER
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    IDENTIFIER      shift and go to state 17

    declaration_list               shift and go to state 31
    sub_decl                       shift and go to state 10
    assignment_expr                shift and go to state 15
    identifier                     shift and go to state 63
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 159

    (118) function_call -> identifier . LP parameter_list RP
    (119) function_call -> identifier . LP RP
    (88) unary_expr -> identifier . INCREMENT
    (89) unary_expr -> identifier . DECREMENT
    (63) sub_decl -> identifier .
    (115) array_access -> identifier . MLP array_index MRP
    (92) lhs -> identifier . seen_id
    (94) seen_id -> .

    LP              shift and go to state 87
    INCREMENT       shift and go to state 32
    DECREMENT       shift and go to state 33
    SEMICOLON       reduce using rule 63 (sub_decl -> identifier .)
    COMMA           reduce using rule 63 (sub_decl -> identifier .)
    MLP             shift and go to state 34
    ASSIGN          reduce using rule 94 (seen_id -> .)
    ADD_ASSIGN      reduce using rule 94 (seen_id -> .)
    SUB_ASSIGN      reduce using rule 94 (seen_id -> .)
    DIV_ASSIGN      reduce using rule 94 (seen_id -> .)
    MOD_ASSIGN      reduce using rule 94 (seen_id -> .)
    MUL_ASSIGN      reduce using rule 94 (seen_id -> .)

    seen_id                        shift and go to state 35

state 160

    (120) prntf_call -> PRNTF . LP STRING RP
    (121) prntf_call -> PRNTF . LP STRING COMMA parameter_list RP

    LP              shift and go to state 173


state 161

    (38) single_stmt -> if_block seen_control .

    BRP             reduce using rule 38 (single_stmt -> if_block seen_control .)
    BLP             reduce using rule 38 (single_stmt -> if_block seen_control .)
    RETURN          reduce using rule 38 (single_stmt -> if_block seen_control .)
    CONTINUE        reduce using rule 38 (single_stmt -> if_block seen_control .)
    BREAK           reduce using rule 38 (single_stmt -> if_block seen_control .)
    IF              reduce using rule 38 (single_stmt -> if_block seen_control .)
    FOR             reduce using rule 38 (single_stmt -> if_block seen_control .)
    WHILE           reduce using rule 38 (single_stmt -> if_block seen_control .)
    PRNTF           reduce using rule 38 (single_stmt -> if_block seen_control .)
    DECREMENT       reduce using rule 38 (single_stmt -> if_block seen_control .)
    INCREMENT       reduce using rule 38 (single_stmt -> if_block seen_control .)
    IDENTIFIER      reduce using rule 38 (single_stmt -> if_block seen_control .)
    SIGNED          reduce using rule 38 (single_stmt -> if_block seen_control .)
    UNSIGNED        reduce using rule 38 (single_stmt -> if_block seen_control .)
    INT             reduce using rule 38 (single_stmt -> if_block seen_control .)
    SHORT           reduce using rule 38 (single_stmt -> if_block seen_control .)
    LONG            reduce using rule 38 (single_stmt -> if_block seen_control .)
    LONG_LONG       reduce using rule 38 (single_stmt -> if_block seen_control .)
    CHAR            reduce using rule 38 (single_stmt -> if_block seen_control .)
    FLOAT           reduce using rule 38 (single_stmt -> if_block seen_control .)
    VOID            reduce using rule 38 (single_stmt -> if_block seen_control .)
    CHAR_STAR       reduce using rule 38 (single_stmt -> if_block seen_control .)
    ELSE            reduce using rule 38 (single_stmt -> if_block seen_control .)


state 162

    (39) single_stmt -> for_block seen_control .

    BRP             reduce using rule 39 (single_stmt -> for_block seen_control .)
    BLP             reduce using rule 39 (single_stmt -> for_block seen_control .)
    RETURN          reduce using rule 39 (single_stmt -> for_block seen_control .)
    CONTINUE        reduce using rule 39 (single_stmt -> for_block seen_control .)
    BREAK           reduce using rule 39 (single_stmt -> for_block seen_control .)
    IF              reduce using rule 39 (single_stmt -> for_block seen_control .)
    FOR             reduce using rule 39 (single_stmt -> for_block seen_control .)
    WHILE           reduce using rule 39 (single_stmt -> for_block seen_control .)
    PRNTF           reduce using rule 39 (single_stmt -> for_block seen_control .)
    DECREMENT       reduce using rule 39 (single_stmt -> for_block seen_control .)
    INCREMENT       reduce using rule 39 (single_stmt -> for_block seen_control .)
    IDENTIFIER      reduce using rule 39 (single_stmt -> for_block seen_control .)
    SIGNED          reduce using rule 39 (single_stmt -> for_block seen_control .)
    UNSIGNED        reduce using rule 39 (single_stmt -> for_block seen_control .)
    INT             reduce using rule 39 (single_stmt -> for_block seen_control .)
    SHORT           reduce using rule 39 (single_stmt -> for_block seen_control .)
    LONG            reduce using rule 39 (single_stmt -> for_block seen_control .)
    LONG_LONG       reduce using rule 39 (single_stmt -> for_block seen_control .)
    CHAR            reduce using rule 39 (single_stmt -> for_block seen_control .)
    FLOAT           reduce using rule 39 (single_stmt -> for_block seen_control .)
    VOID            reduce using rule 39 (single_stmt -> for_block seen_control .)
    CHAR_STAR       reduce using rule 39 (single_stmt -> for_block seen_control .)
    ELSE            reduce using rule 39 (single_stmt -> for_block seen_control .)


state 163

    (40) single_stmt -> while_block seen_control .

    BRP             reduce using rule 40 (single_stmt -> while_block seen_control .)
    BLP             reduce using rule 40 (single_stmt -> while_block seen_control .)
    RETURN          reduce using rule 40 (single_stmt -> while_block seen_control .)
    CONTINUE        reduce using rule 40 (single_stmt -> while_block seen_control .)
    BREAK           reduce using rule 40 (single_stmt -> while_block seen_control .)
    IF              reduce using rule 40 (single_stmt -> while_block seen_control .)
    FOR             reduce using rule 40 (single_stmt -> while_block seen_control .)
    WHILE           reduce using rule 40 (single_stmt -> while_block seen_control .)
    PRNTF           reduce using rule 40 (single_stmt -> while_block seen_control .)
    DECREMENT       reduce using rule 40 (single_stmt -> while_block seen_control .)
    INCREMENT       reduce using rule 40 (single_stmt -> while_block seen_control .)
    IDENTIFIER      reduce using rule 40 (single_stmt -> while_block seen_control .)
    SIGNED          reduce using rule 40 (single_stmt -> while_block seen_control .)
    UNSIGNED        reduce using rule 40 (single_stmt -> while_block seen_control .)
    INT             reduce using rule 40 (single_stmt -> while_block seen_control .)
    SHORT           reduce using rule 40 (single_stmt -> while_block seen_control .)
    LONG            reduce using rule 40 (single_stmt -> while_block seen_control .)
    LONG_LONG       reduce using rule 40 (single_stmt -> while_block seen_control .)
    CHAR            reduce using rule 40 (single_stmt -> while_block seen_control .)
    FLOAT           reduce using rule 40 (single_stmt -> while_block seen_control .)
    VOID            reduce using rule 40 (single_stmt -> while_block seen_control .)
    CHAR_STAR       reduce using rule 40 (single_stmt -> while_block seen_control .)
    ELSE            reduce using rule 40 (single_stmt -> while_block seen_control .)


state 164

    (42) single_stmt -> function_call SEMICOLON .

    BRP             reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    BLP             reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    RETURN          reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    CONTINUE        reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    BREAK           reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    IF              reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    FOR             reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    WHILE           reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    PRNTF           reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    DECREMENT       reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    INCREMENT       reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    SIGNED          reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    UNSIGNED        reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    INT             reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    SHORT           reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    LONG            reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    LONG_LONG       reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    CHAR            reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    FLOAT           reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    VOID            reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    CHAR_STAR       reduce using rule 42 (single_stmt -> function_call SEMICOLON .)
    ELSE            reduce using rule 42 (single_stmt -> function_call SEMICOLON .)


state 165

    (43) single_stmt -> RETURN SEMICOLON .

    BRP             reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    BLP             reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    PRNTF           reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    SIGNED          reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    UNSIGNED        reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    SHORT           reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    LONG            reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    LONG_LONG       reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    CHAR            reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    VOID            reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    CHAR_STAR       reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 43 (single_stmt -> RETURN SEMICOLON .)


state 166

    (45) single_stmt -> RETURN sub_expr . SEMICOLON
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    SEMICOLON       shift and go to state 174
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119
    LOGICAL_AND     shift and go to state 120
    LOGICAL_OR      shift and go to state 121


state 167

    (44) single_stmt -> prntf_call SEMICOLON .

    BRP             reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    BLP             reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    RETURN          reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    CONTINUE        reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    BREAK           reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    IF              reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    FOR             reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    WHILE           reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    PRNTF           reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    DECREMENT       reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    INCREMENT       reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    SIGNED          reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    UNSIGNED        reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    INT             reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    SHORT           reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    LONG            reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    LONG_LONG       reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    CHAR            reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    FLOAT           reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    VOID            reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    CHAR_STAR       reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)
    ELSE            reduce using rule 44 (single_stmt -> prntf_call SEMICOLON .)


state 168

    (46) single_stmt -> CONTINUE SEMICOLON .

    BRP             reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    BLP             reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    PRNTF           reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    SIGNED          reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    UNSIGNED        reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    SHORT           reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    LONG            reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    LONG_LONG       reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    CHAR_STAR       reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 46 (single_stmt -> CONTINUE SEMICOLON .)


state 169

    (47) single_stmt -> BREAK SEMICOLON .

    BRP             reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    BLP             reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    PRNTF           reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    SIGNED          reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    UNSIGNED        reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    SHORT           reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    LONG            reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    LONG_LONG       reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    CHAR            reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    CHAR_STAR       reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 47 (single_stmt -> BREAK SEMICOLON .)


state 170

    (54) if_block -> IF LP . expression RP M stmt ELSE N M stmt
    (55) if_block -> IF LP . expression RP M stmt
    (65) expression -> . expression COMMA sub_expr
    (66) expression -> . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    expression                     shift and go to state 175
    sub_expr                       shift and go to state 176
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 171

    (51) for_block -> FOR LP . expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (49) expression_stmt -> . expression SEMICOLON
    (50) expression_stmt -> . SEMICOLON
    (65) expression -> . expression COMMA sub_expr
    (66) expression -> . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    SEMICOLON       shift and go to state 179
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    expression_stmt                shift and go to state 177
    expression                     shift and go to state 178
    sub_expr                       shift and go to state 176
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 172

    (56) while_block -> WHILE M . LP expression RP M before_loop stmt after_loop

    LP              shift and go to state 180


state 173

    (120) prntf_call -> PRNTF LP . STRING RP
    (121) prntf_call -> PRNTF LP . STRING COMMA parameter_list RP

    STRING          shift and go to state 181


state 174

    (45) single_stmt -> RETURN sub_expr SEMICOLON .

    BRP             reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    BLP             reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    RETURN          reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    CONTINUE        reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    BREAK           reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    IF              reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    FOR             reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    WHILE           reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    PRNTF           reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    DECREMENT       reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    INCREMENT       reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    IDENTIFIER      reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    SIGNED          reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    UNSIGNED        reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    INT             reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    SHORT           reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    LONG            reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    LONG_LONG       reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    CHAR            reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    FLOAT           reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    VOID            reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    CHAR_STAR       reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)
    ELSE            reduce using rule 45 (single_stmt -> RETURN sub_expr SEMICOLON .)


state 175

    (54) if_block -> IF LP expression . RP M stmt ELSE N M stmt
    (55) if_block -> IF LP expression . RP M stmt
    (65) expression -> expression . COMMA sub_expr

    RP              shift and go to state 182
    COMMA           shift and go to state 183


state 176

    (66) expression -> sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    RP              reduce using rule 66 (expression -> sub_expr .)
    COMMA           reduce using rule 66 (expression -> sub_expr .)
    SEMICOLON       reduce using rule 66 (expression -> sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119
    LOGICAL_AND     shift and go to state 120
    LOGICAL_OR      shift and go to state 121


state 177

    (51) for_block -> FOR LP expression_stmt . M expression_stmt M expression RP before_loop N M stmt after_loop
    (126) M -> .

    SEMICOLON       reduce using rule 126 (M -> .)
    NOT             reduce using rule 126 (M -> .)
    LP              reduce using rule 126 (M -> .)
    SUB             reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    DEC_CONSTANT    reduce using rule 126 (M -> .)
    HEX_CONSTANT    reduce using rule 126 (M -> .)
    CHAR_CONSTANT   reduce using rule 126 (M -> .)
    FLOAT_CONSTANT  reduce using rule 126 (M -> .)

    M                              shift and go to state 184

state 178

    (49) expression_stmt -> expression . SEMICOLON
    (65) expression -> expression . COMMA sub_expr

    SEMICOLON       shift and go to state 185
    COMMA           shift and go to state 183


state 179

    (50) expression_stmt -> SEMICOLON .

    SEMICOLON       reduce using rule 50 (expression_stmt -> SEMICOLON .)
    NOT             reduce using rule 50 (expression_stmt -> SEMICOLON .)
    LP              reduce using rule 50 (expression_stmt -> SEMICOLON .)
    SUB             reduce using rule 50 (expression_stmt -> SEMICOLON .)
    DECREMENT       reduce using rule 50 (expression_stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 50 (expression_stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (expression_stmt -> SEMICOLON .)
    DEC_CONSTANT    reduce using rule 50 (expression_stmt -> SEMICOLON .)
    HEX_CONSTANT    reduce using rule 50 (expression_stmt -> SEMICOLON .)
    CHAR_CONSTANT   reduce using rule 50 (expression_stmt -> SEMICOLON .)
    FLOAT_CONSTANT  reduce using rule 50 (expression_stmt -> SEMICOLON .)


state 180

    (56) while_block -> WHILE M LP . expression RP M before_loop stmt after_loop
    (65) expression -> . expression COMMA sub_expr
    (66) expression -> . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    expression                     shift and go to state 186
    sub_expr                       shift and go to state 176
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 181

    (120) prntf_call -> PRNTF LP STRING . RP
    (121) prntf_call -> PRNTF LP STRING . COMMA parameter_list RP

    RP              shift and go to state 187
    COMMA           shift and go to state 188


state 182

    (54) if_block -> IF LP expression RP . M stmt ELSE N M stmt
    (55) if_block -> IF LP expression RP . M stmt
    (126) M -> .

    BLP             reduce using rule 126 (M -> .)
    RETURN          reduce using rule 126 (M -> .)
    CONTINUE        reduce using rule 126 (M -> .)
    BREAK           reduce using rule 126 (M -> .)
    IF              reduce using rule 126 (M -> .)
    FOR             reduce using rule 126 (M -> .)
    WHILE           reduce using rule 126 (M -> .)
    PRNTF           reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    SIGNED          reduce using rule 126 (M -> .)
    UNSIGNED        reduce using rule 126 (M -> .)
    INT             reduce using rule 126 (M -> .)
    SHORT           reduce using rule 126 (M -> .)
    LONG            reduce using rule 126 (M -> .)
    LONG_LONG       reduce using rule 126 (M -> .)
    CHAR            reduce using rule 126 (M -> .)
    FLOAT           reduce using rule 126 (M -> .)
    VOID            reduce using rule 126 (M -> .)
    CHAR_STAR       reduce using rule 126 (M -> .)

    M                              shift and go to state 189

state 183

    (65) expression -> expression COMMA . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    sub_expr                       shift and go to state 190
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 184

    (51) for_block -> FOR LP expression_stmt M . expression_stmt M expression RP before_loop N M stmt after_loop
    (49) expression_stmt -> . expression SEMICOLON
    (50) expression_stmt -> . SEMICOLON
    (65) expression -> . expression COMMA sub_expr
    (66) expression -> . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    SEMICOLON       shift and go to state 179
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    expression_stmt                shift and go to state 191
    expression                     shift and go to state 178
    sub_expr                       shift and go to state 176
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 185

    (49) expression_stmt -> expression SEMICOLON .

    SEMICOLON       reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    NOT             reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    LP              reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    SUB             reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    DECREMENT       reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    INCREMENT       reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    DEC_CONSTANT    reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    HEX_CONSTANT    reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    CHAR_CONSTANT   reduce using rule 49 (expression_stmt -> expression SEMICOLON .)
    FLOAT_CONSTANT  reduce using rule 49 (expression_stmt -> expression SEMICOLON .)


state 186

    (56) while_block -> WHILE M LP expression . RP M before_loop stmt after_loop
    (65) expression -> expression . COMMA sub_expr

    RP              shift and go to state 192
    COMMA           shift and go to state 183


state 187

    (120) prntf_call -> PRNTF LP STRING RP .

    SEMICOLON       reduce using rule 120 (prntf_call -> PRNTF LP STRING RP .)


state 188

    (121) prntf_call -> PRNTF LP STRING COMMA . parameter_list RP
    (122) parameter_list -> . parameter_list COMMA parameter
    (123) parameter_list -> . parameter
    (124) parameter -> . sub_expr
    (125) parameter -> . STRING
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    STRING          shift and go to state 103
    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    parameter_list                 shift and go to state 193
    parameter                      shift and go to state 101
    sub_expr                       shift and go to state 102
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 189

    (54) if_block -> IF LP expression RP M . stmt ELSE N M stmt
    (55) if_block -> IF LP expression RP M . stmt
    (32) stmt -> . compound_stmt
    (33) stmt -> . single_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP
    (38) single_stmt -> . if_block seen_control
    (39) single_stmt -> . for_block seen_control
    (40) single_stmt -> . while_block seen_control
    (41) single_stmt -> . declaration
    (42) single_stmt -> . function_call SEMICOLON
    (43) single_stmt -> . RETURN SEMICOLON
    (44) single_stmt -> . prntf_call SEMICOLON
    (45) single_stmt -> . RETURN sub_expr SEMICOLON
    (46) single_stmt -> . CONTINUE SEMICOLON
    (47) single_stmt -> . BREAK SEMICOLON
    (54) if_block -> . IF LP expression RP M stmt ELSE N M stmt
    (55) if_block -> . IF LP expression RP M stmt
    (51) for_block -> . FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (56) while_block -> . WHILE M LP expression RP M before_loop stmt after_loop
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (120) prntf_call -> . PRNTF LP STRING RP
    (121) prntf_call -> . PRNTF LP STRING COMMA parameter_list RP
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    BLP             shift and go to state 136
    RETURN          shift and go to state 151
    CONTINUE        shift and go to state 153
    BREAK           shift and go to state 154
    IF              shift and go to state 155
    FOR             shift and go to state 156
    WHILE           shift and go to state 157
    PRNTF           shift and go to state 160
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    stmt                           shift and go to state 194
    compound_stmt                  shift and go to state 144
    single_stmt                    shift and go to state 145
    if_block                       shift and go to state 146
    for_block                      shift and go to state 147
    while_block                    shift and go to state 148
    declaration                    shift and go to state 149
    function_call                  shift and go to state 150
    prntf_call                     shift and go to state 152
    type                           shift and go to state 158
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    identifier                     shift and go to state 159
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 190

    (65) expression -> expression COMMA sub_expr .
    (67) sub_expr -> sub_expr . GR sub_expr
    (68) sub_expr -> sub_expr . LS sub_expr
    (69) sub_expr -> sub_expr . EQ sub_expr
    (70) sub_expr -> sub_expr . NOT_EQ sub_expr
    (71) sub_expr -> sub_expr . GR_EQ sub_expr
    (72) sub_expr -> sub_expr . LS_EQ sub_expr
    (73) sub_expr -> sub_expr . LOGICAL_AND M sub_expr
    (74) sub_expr -> sub_expr . LOGICAL_OR M sub_expr

    RP              reduce using rule 65 (expression -> expression COMMA sub_expr .)
    COMMA           reduce using rule 65 (expression -> expression COMMA sub_expr .)
    SEMICOLON       reduce using rule 65 (expression -> expression COMMA sub_expr .)
    GR              shift and go to state 114
    LS              shift and go to state 115
    EQ              shift and go to state 116
    NOT_EQ          shift and go to state 117
    GR_EQ           shift and go to state 118
    LS_EQ           shift and go to state 119
    LOGICAL_AND     shift and go to state 120
    LOGICAL_OR      shift and go to state 121


state 191

    (51) for_block -> FOR LP expression_stmt M expression_stmt . M expression RP before_loop N M stmt after_loop
    (126) M -> .

    NOT             reduce using rule 126 (M -> .)
    LP              reduce using rule 126 (M -> .)
    SUB             reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    DEC_CONSTANT    reduce using rule 126 (M -> .)
    HEX_CONSTANT    reduce using rule 126 (M -> .)
    CHAR_CONSTANT   reduce using rule 126 (M -> .)
    FLOAT_CONSTANT  reduce using rule 126 (M -> .)

    M                              shift and go to state 195

state 192

    (56) while_block -> WHILE M LP expression RP . M before_loop stmt after_loop
    (126) M -> .

    BLP             reduce using rule 126 (M -> .)
    RETURN          reduce using rule 126 (M -> .)
    CONTINUE        reduce using rule 126 (M -> .)
    BREAK           reduce using rule 126 (M -> .)
    IF              reduce using rule 126 (M -> .)
    FOR             reduce using rule 126 (M -> .)
    WHILE           reduce using rule 126 (M -> .)
    PRNTF           reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    SIGNED          reduce using rule 126 (M -> .)
    UNSIGNED        reduce using rule 126 (M -> .)
    INT             reduce using rule 126 (M -> .)
    SHORT           reduce using rule 126 (M -> .)
    LONG            reduce using rule 126 (M -> .)
    LONG_LONG       reduce using rule 126 (M -> .)
    CHAR            reduce using rule 126 (M -> .)
    FLOAT           reduce using rule 126 (M -> .)
    VOID            reduce using rule 126 (M -> .)
    CHAR_STAR       reduce using rule 126 (M -> .)

    M                              shift and go to state 196

state 193

    (121) prntf_call -> PRNTF LP STRING COMMA parameter_list . RP
    (122) parameter_list -> parameter_list . COMMA parameter

    RP              shift and go to state 197
    COMMA           shift and go to state 113


state 194

    (54) if_block -> IF LP expression RP M stmt . ELSE N M stmt
    (55) if_block -> IF LP expression RP M stmt .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 198
    BRP             reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    BLP             reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    RETURN          reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    CONTINUE        reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    BREAK           reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    IF              reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    FOR             reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    WHILE           reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    PRNTF           reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    DECREMENT       reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    INCREMENT       reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    IDENTIFIER      reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    SIGNED          reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    UNSIGNED        reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    INT             reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    SHORT           reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    LONG            reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    LONG_LONG       reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    CHAR            reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    FLOAT           reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    VOID            reduce using rule 55 (if_block -> IF LP expression RP M stmt .)
    CHAR_STAR       reduce using rule 55 (if_block -> IF LP expression RP M stmt .)

  ! ELSE            [ reduce using rule 55 (if_block -> IF LP expression RP M stmt .) ]


state 195

    (51) for_block -> FOR LP expression_stmt M expression_stmt M . expression RP before_loop N M stmt after_loop
    (65) expression -> . expression COMMA sub_expr
    (66) expression -> . sub_expr
    (67) sub_expr -> . sub_expr GR sub_expr
    (68) sub_expr -> . sub_expr LS sub_expr
    (69) sub_expr -> . sub_expr EQ sub_expr
    (70) sub_expr -> . sub_expr NOT_EQ sub_expr
    (71) sub_expr -> . sub_expr GR_EQ sub_expr
    (72) sub_expr -> . sub_expr LS_EQ sub_expr
    (73) sub_expr -> . sub_expr LOGICAL_AND M sub_expr
    (74) sub_expr -> . sub_expr LOGICAL_OR M sub_expr
    (75) sub_expr -> . NOT sub_expr
    (76) sub_expr -> . arithmetic_expr seen_arith
    (77) sub_expr -> . assignment_expr
    (78) sub_expr -> . unary_expr
    (102) arithmetic_expr -> . arithmetic_expr ADD arithmetic_expr
    (103) arithmetic_expr -> . arithmetic_expr SUB arithmetic_expr
    (104) arithmetic_expr -> . arithmetic_expr MUL arithmetic_expr
    (105) arithmetic_expr -> . arithmetic_expr DIV arithmetic_expr
    (106) arithmetic_expr -> . arithmetic_expr MOD arithmetic_expr
    (107) arithmetic_expr -> . LP arithmetic_expr RP
    (108) arithmetic_expr -> . SUB arithmetic_expr
    (109) arithmetic_expr -> . identifier
    (110) arithmetic_expr -> . constant
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (111) constant -> . DEC_CONSTANT
    (112) constant -> . HEX_CONSTANT
    (113) constant -> . CHAR_CONSTANT
    (114) constant -> . FLOAT_CONSTANT
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access
    (115) array_access -> . identifier MLP array_index MRP

    NOT             shift and go to state 104
    LP              shift and go to state 70
    SUB             shift and go to state 69
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    DEC_CONSTANT    shift and go to state 58
    HEX_CONSTANT    shift and go to state 59
    CHAR_CONSTANT   shift and go to state 60
    FLOAT_CONSTANT  shift and go to state 61

    expression                     shift and go to state 199
    sub_expr                       shift and go to state 176
    arithmetic_expr                shift and go to state 105
    assignment_expr                shift and go to state 106
    unary_expr                     shift and go to state 107
    identifier                     shift and go to state 98
    constant                       shift and go to state 72
    lhs                            shift and go to state 28
    array_access                   shift and go to state 108

state 196

    (56) while_block -> WHILE M LP expression RP M . before_loop stmt after_loop
    (52) before_loop -> .

    BLP             reduce using rule 52 (before_loop -> .)
    RETURN          reduce using rule 52 (before_loop -> .)
    CONTINUE        reduce using rule 52 (before_loop -> .)
    BREAK           reduce using rule 52 (before_loop -> .)
    IF              reduce using rule 52 (before_loop -> .)
    FOR             reduce using rule 52 (before_loop -> .)
    WHILE           reduce using rule 52 (before_loop -> .)
    PRNTF           reduce using rule 52 (before_loop -> .)
    DECREMENT       reduce using rule 52 (before_loop -> .)
    INCREMENT       reduce using rule 52 (before_loop -> .)
    IDENTIFIER      reduce using rule 52 (before_loop -> .)
    SIGNED          reduce using rule 52 (before_loop -> .)
    UNSIGNED        reduce using rule 52 (before_loop -> .)
    INT             reduce using rule 52 (before_loop -> .)
    SHORT           reduce using rule 52 (before_loop -> .)
    LONG            reduce using rule 52 (before_loop -> .)
    LONG_LONG       reduce using rule 52 (before_loop -> .)
    CHAR            reduce using rule 52 (before_loop -> .)
    FLOAT           reduce using rule 52 (before_loop -> .)
    VOID            reduce using rule 52 (before_loop -> .)
    CHAR_STAR       reduce using rule 52 (before_loop -> .)

    before_loop                    shift and go to state 200

state 197

    (121) prntf_call -> PRNTF LP STRING COMMA parameter_list RP .

    SEMICOLON       reduce using rule 121 (prntf_call -> PRNTF LP STRING COMMA parameter_list RP .)


state 198

    (54) if_block -> IF LP expression RP M stmt ELSE . N M stmt
    (127) N -> .

    BLP             reduce using rule 127 (N -> .)
    RETURN          reduce using rule 127 (N -> .)
    CONTINUE        reduce using rule 127 (N -> .)
    BREAK           reduce using rule 127 (N -> .)
    IF              reduce using rule 127 (N -> .)
    FOR             reduce using rule 127 (N -> .)
    WHILE           reduce using rule 127 (N -> .)
    PRNTF           reduce using rule 127 (N -> .)
    DECREMENT       reduce using rule 127 (N -> .)
    INCREMENT       reduce using rule 127 (N -> .)
    IDENTIFIER      reduce using rule 127 (N -> .)
    SIGNED          reduce using rule 127 (N -> .)
    UNSIGNED        reduce using rule 127 (N -> .)
    INT             reduce using rule 127 (N -> .)
    SHORT           reduce using rule 127 (N -> .)
    LONG            reduce using rule 127 (N -> .)
    LONG_LONG       reduce using rule 127 (N -> .)
    CHAR            reduce using rule 127 (N -> .)
    FLOAT           reduce using rule 127 (N -> .)
    VOID            reduce using rule 127 (N -> .)
    CHAR_STAR       reduce using rule 127 (N -> .)

    N                              shift and go to state 201

state 199

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression . RP before_loop N M stmt after_loop
    (65) expression -> expression . COMMA sub_expr

    RP              shift and go to state 202
    COMMA           shift and go to state 183


state 200

    (56) while_block -> WHILE M LP expression RP M before_loop . stmt after_loop
    (32) stmt -> . compound_stmt
    (33) stmt -> . single_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP
    (38) single_stmt -> . if_block seen_control
    (39) single_stmt -> . for_block seen_control
    (40) single_stmt -> . while_block seen_control
    (41) single_stmt -> . declaration
    (42) single_stmt -> . function_call SEMICOLON
    (43) single_stmt -> . RETURN SEMICOLON
    (44) single_stmt -> . prntf_call SEMICOLON
    (45) single_stmt -> . RETURN sub_expr SEMICOLON
    (46) single_stmt -> . CONTINUE SEMICOLON
    (47) single_stmt -> . BREAK SEMICOLON
    (54) if_block -> . IF LP expression RP M stmt ELSE N M stmt
    (55) if_block -> . IF LP expression RP M stmt
    (51) for_block -> . FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (56) while_block -> . WHILE M LP expression RP M before_loop stmt after_loop
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (120) prntf_call -> . PRNTF LP STRING RP
    (121) prntf_call -> . PRNTF LP STRING COMMA parameter_list RP
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    BLP             shift and go to state 136
    RETURN          shift and go to state 151
    CONTINUE        shift and go to state 153
    BREAK           shift and go to state 154
    IF              shift and go to state 155
    FOR             shift and go to state 156
    WHILE           shift and go to state 157
    PRNTF           shift and go to state 160
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    stmt                           shift and go to state 203
    compound_stmt                  shift and go to state 144
    single_stmt                    shift and go to state 145
    if_block                       shift and go to state 146
    for_block                      shift and go to state 147
    while_block                    shift and go to state 148
    declaration                    shift and go to state 149
    function_call                  shift and go to state 150
    prntf_call                     shift and go to state 152
    type                           shift and go to state 158
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    identifier                     shift and go to state 159
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 201

    (54) if_block -> IF LP expression RP M stmt ELSE N . M stmt
    (126) M -> .

    BLP             reduce using rule 126 (M -> .)
    RETURN          reduce using rule 126 (M -> .)
    CONTINUE        reduce using rule 126 (M -> .)
    BREAK           reduce using rule 126 (M -> .)
    IF              reduce using rule 126 (M -> .)
    FOR             reduce using rule 126 (M -> .)
    WHILE           reduce using rule 126 (M -> .)
    PRNTF           reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    SIGNED          reduce using rule 126 (M -> .)
    UNSIGNED        reduce using rule 126 (M -> .)
    INT             reduce using rule 126 (M -> .)
    SHORT           reduce using rule 126 (M -> .)
    LONG            reduce using rule 126 (M -> .)
    LONG_LONG       reduce using rule 126 (M -> .)
    CHAR            reduce using rule 126 (M -> .)
    FLOAT           reduce using rule 126 (M -> .)
    VOID            reduce using rule 126 (M -> .)
    CHAR_STAR       reduce using rule 126 (M -> .)

    M                              shift and go to state 204

state 202

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP . before_loop N M stmt after_loop
    (52) before_loop -> .

    BLP             reduce using rule 52 (before_loop -> .)
    RETURN          reduce using rule 52 (before_loop -> .)
    CONTINUE        reduce using rule 52 (before_loop -> .)
    BREAK           reduce using rule 52 (before_loop -> .)
    IF              reduce using rule 52 (before_loop -> .)
    FOR             reduce using rule 52 (before_loop -> .)
    WHILE           reduce using rule 52 (before_loop -> .)
    PRNTF           reduce using rule 52 (before_loop -> .)
    DECREMENT       reduce using rule 52 (before_loop -> .)
    INCREMENT       reduce using rule 52 (before_loop -> .)
    IDENTIFIER      reduce using rule 52 (before_loop -> .)
    SIGNED          reduce using rule 52 (before_loop -> .)
    UNSIGNED        reduce using rule 52 (before_loop -> .)
    INT             reduce using rule 52 (before_loop -> .)
    SHORT           reduce using rule 52 (before_loop -> .)
    LONG            reduce using rule 52 (before_loop -> .)
    LONG_LONG       reduce using rule 52 (before_loop -> .)
    CHAR            reduce using rule 52 (before_loop -> .)
    FLOAT           reduce using rule 52 (before_loop -> .)
    VOID            reduce using rule 52 (before_loop -> .)
    CHAR_STAR       reduce using rule 52 (before_loop -> .)

    before_loop                    shift and go to state 205

state 203

    (56) while_block -> WHILE M LP expression RP M before_loop stmt . after_loop
    (53) after_loop -> .

    BRP             reduce using rule 53 (after_loop -> .)
    BLP             reduce using rule 53 (after_loop -> .)
    RETURN          reduce using rule 53 (after_loop -> .)
    CONTINUE        reduce using rule 53 (after_loop -> .)
    BREAK           reduce using rule 53 (after_loop -> .)
    IF              reduce using rule 53 (after_loop -> .)
    FOR             reduce using rule 53 (after_loop -> .)
    WHILE           reduce using rule 53 (after_loop -> .)
    PRNTF           reduce using rule 53 (after_loop -> .)
    DECREMENT       reduce using rule 53 (after_loop -> .)
    INCREMENT       reduce using rule 53 (after_loop -> .)
    IDENTIFIER      reduce using rule 53 (after_loop -> .)
    SIGNED          reduce using rule 53 (after_loop -> .)
    UNSIGNED        reduce using rule 53 (after_loop -> .)
    INT             reduce using rule 53 (after_loop -> .)
    SHORT           reduce using rule 53 (after_loop -> .)
    LONG            reduce using rule 53 (after_loop -> .)
    LONG_LONG       reduce using rule 53 (after_loop -> .)
    CHAR            reduce using rule 53 (after_loop -> .)
    FLOAT           reduce using rule 53 (after_loop -> .)
    VOID            reduce using rule 53 (after_loop -> .)
    CHAR_STAR       reduce using rule 53 (after_loop -> .)
    ELSE            reduce using rule 53 (after_loop -> .)

    after_loop                     shift and go to state 206

state 204

    (54) if_block -> IF LP expression RP M stmt ELSE N M . stmt
    (32) stmt -> . compound_stmt
    (33) stmt -> . single_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP
    (38) single_stmt -> . if_block seen_control
    (39) single_stmt -> . for_block seen_control
    (40) single_stmt -> . while_block seen_control
    (41) single_stmt -> . declaration
    (42) single_stmt -> . function_call SEMICOLON
    (43) single_stmt -> . RETURN SEMICOLON
    (44) single_stmt -> . prntf_call SEMICOLON
    (45) single_stmt -> . RETURN sub_expr SEMICOLON
    (46) single_stmt -> . CONTINUE SEMICOLON
    (47) single_stmt -> . BREAK SEMICOLON
    (54) if_block -> . IF LP expression RP M stmt ELSE N M stmt
    (55) if_block -> . IF LP expression RP M stmt
    (51) for_block -> . FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (56) while_block -> . WHILE M LP expression RP M before_loop stmt after_loop
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (120) prntf_call -> . PRNTF LP STRING RP
    (121) prntf_call -> . PRNTF LP STRING COMMA parameter_list RP
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    BLP             shift and go to state 136
    RETURN          shift and go to state 151
    CONTINUE        shift and go to state 153
    BREAK           shift and go to state 154
    IF              shift and go to state 155
    FOR             shift and go to state 156
    WHILE           shift and go to state 157
    PRNTF           shift and go to state 160
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    stmt                           shift and go to state 207
    compound_stmt                  shift and go to state 144
    single_stmt                    shift and go to state 145
    if_block                       shift and go to state 146
    for_block                      shift and go to state 147
    while_block                    shift and go to state 148
    declaration                    shift and go to state 149
    function_call                  shift and go to state 150
    prntf_call                     shift and go to state 152
    type                           shift and go to state 158
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    identifier                     shift and go to state 159
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 205

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop . N M stmt after_loop
    (127) N -> .

    BLP             reduce using rule 127 (N -> .)
    RETURN          reduce using rule 127 (N -> .)
    CONTINUE        reduce using rule 127 (N -> .)
    BREAK           reduce using rule 127 (N -> .)
    IF              reduce using rule 127 (N -> .)
    FOR             reduce using rule 127 (N -> .)
    WHILE           reduce using rule 127 (N -> .)
    PRNTF           reduce using rule 127 (N -> .)
    DECREMENT       reduce using rule 127 (N -> .)
    INCREMENT       reduce using rule 127 (N -> .)
    IDENTIFIER      reduce using rule 127 (N -> .)
    SIGNED          reduce using rule 127 (N -> .)
    UNSIGNED        reduce using rule 127 (N -> .)
    INT             reduce using rule 127 (N -> .)
    SHORT           reduce using rule 127 (N -> .)
    LONG            reduce using rule 127 (N -> .)
    LONG_LONG       reduce using rule 127 (N -> .)
    CHAR            reduce using rule 127 (N -> .)
    FLOAT           reduce using rule 127 (N -> .)
    VOID            reduce using rule 127 (N -> .)
    CHAR_STAR       reduce using rule 127 (N -> .)

    N                              shift and go to state 208

state 206

    (56) while_block -> WHILE M LP expression RP M before_loop stmt after_loop .

    BRP             reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    BLP             reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    RETURN          reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    CONTINUE        reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    BREAK           reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    IF              reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    FOR             reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    WHILE           reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    PRNTF           reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    DECREMENT       reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    INCREMENT       reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    IDENTIFIER      reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    SIGNED          reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    UNSIGNED        reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    INT             reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    SHORT           reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    LONG            reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    LONG_LONG       reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    CHAR            reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    FLOAT           reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    VOID            reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    CHAR_STAR       reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)
    ELSE            reduce using rule 56 (while_block -> WHILE M LP expression RP M before_loop stmt after_loop .)


state 207

    (54) if_block -> IF LP expression RP M stmt ELSE N M stmt .

    BRP             reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    BLP             reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    RETURN          reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    CONTINUE        reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    BREAK           reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    IF              reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    FOR             reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    WHILE           reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    PRNTF           reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    DECREMENT       reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    INCREMENT       reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    IDENTIFIER      reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    SIGNED          reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    UNSIGNED        reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    INT             reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    SHORT           reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    LONG            reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    LONG_LONG       reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    CHAR            reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    FLOAT           reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    VOID            reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    CHAR_STAR       reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)
    ELSE            reduce using rule 54 (if_block -> IF LP expression RP M stmt ELSE N M stmt .)


state 208

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N . M stmt after_loop
    (126) M -> .

    BLP             reduce using rule 126 (M -> .)
    RETURN          reduce using rule 126 (M -> .)
    CONTINUE        reduce using rule 126 (M -> .)
    BREAK           reduce using rule 126 (M -> .)
    IF              reduce using rule 126 (M -> .)
    FOR             reduce using rule 126 (M -> .)
    WHILE           reduce using rule 126 (M -> .)
    PRNTF           reduce using rule 126 (M -> .)
    DECREMENT       reduce using rule 126 (M -> .)
    INCREMENT       reduce using rule 126 (M -> .)
    IDENTIFIER      reduce using rule 126 (M -> .)
    SIGNED          reduce using rule 126 (M -> .)
    UNSIGNED        reduce using rule 126 (M -> .)
    INT             reduce using rule 126 (M -> .)
    SHORT           reduce using rule 126 (M -> .)
    LONG            reduce using rule 126 (M -> .)
    LONG_LONG       reduce using rule 126 (M -> .)
    CHAR            reduce using rule 126 (M -> .)
    FLOAT           reduce using rule 126 (M -> .)
    VOID            reduce using rule 126 (M -> .)
    CHAR_STAR       reduce using rule 126 (M -> .)

    M                              shift and go to state 209

state 209

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M . stmt after_loop
    (32) stmt -> . compound_stmt
    (33) stmt -> . single_stmt
    (34) compound_stmt -> . BLP seen_BLP statements BRP
    (38) single_stmt -> . if_block seen_control
    (39) single_stmt -> . for_block seen_control
    (40) single_stmt -> . while_block seen_control
    (41) single_stmt -> . declaration
    (42) single_stmt -> . function_call SEMICOLON
    (43) single_stmt -> . RETURN SEMICOLON
    (44) single_stmt -> . prntf_call SEMICOLON
    (45) single_stmt -> . RETURN sub_expr SEMICOLON
    (46) single_stmt -> . CONTINUE SEMICOLON
    (47) single_stmt -> . BREAK SEMICOLON
    (54) if_block -> . IF LP expression RP M stmt ELSE N M stmt
    (55) if_block -> . IF LP expression RP M stmt
    (51) for_block -> . FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop
    (56) while_block -> . WHILE M LP expression RP M before_loop stmt after_loop
    (57) declaration -> . type declaration_list SEMICOLON
    (58) declaration -> . declaration_list SEMICOLON
    (59) declaration -> . unary_expr
    (118) function_call -> . identifier LP parameter_list RP
    (119) function_call -> . identifier LP RP
    (120) prntf_call -> . PRNTF LP STRING RP
    (121) prntf_call -> . PRNTF LP STRING COMMA parameter_list RP
    (8) type -> . data_type pointer
    (9) type -> . data_type
    (60) declaration_list -> . declaration_list COMMA sub_decl
    (61) declaration_list -> . sub_decl
    (88) unary_expr -> . identifier INCREMENT
    (89) unary_expr -> . identifier DECREMENT
    (90) unary_expr -> . DECREMENT identifier
    (91) unary_expr -> . INCREMENT identifier
    (95) identifier -> . IDENTIFIER
    (10) data_type -> . sign_specifier type_specifier
    (11) data_type -> . type_specifier
    (62) sub_decl -> . assignment_expr
    (63) sub_decl -> . identifier
    (64) sub_decl -> . array_access
    (14) sign_specifier -> . SIGNED
    (15) sign_specifier -> . UNSIGNED
    (16) type_specifier -> . INT
    (17) type_specifier -> . SHORT INT
    (18) type_specifier -> . SHORT
    (19) type_specifier -> . LONG
    (20) type_specifier -> . LONG_LONG
    (21) type_specifier -> . LONG INT
    (22) type_specifier -> . LONG_LONG INT
    (23) type_specifier -> . CHAR
    (24) type_specifier -> . FLOAT
    (25) type_specifier -> . VOID
    (26) type_specifier -> . CHAR_STAR
    (80) assignment_expr -> . lhs assign arithmetic_expr seen_arch
    (81) assignment_expr -> . lhs assign array_access seen_array
    (82) assignment_expr -> . lhs assign function_call seen_func_call
    (83) assignment_expr -> . lhs assign unary_expr seen_unary
    (115) array_access -> . identifier MLP array_index MRP
    (92) lhs -> . identifier seen_id
    (93) lhs -> . array_access

    BLP             shift and go to state 136
    RETURN          shift and go to state 151
    CONTINUE        shift and go to state 153
    BREAK           shift and go to state 154
    IF              shift and go to state 155
    FOR             shift and go to state 156
    WHILE           shift and go to state 157
    PRNTF           shift and go to state 160
    DECREMENT       shift and go to state 12
    INCREMENT       shift and go to state 11
    IDENTIFIER      shift and go to state 17
    SIGNED          shift and go to state 18
    UNSIGNED        shift and go to state 19
    INT             shift and go to state 20
    SHORT           shift and go to state 21
    LONG            shift and go to state 22
    LONG_LONG       shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    VOID            shift and go to state 26
    CHAR_STAR       shift and go to state 27

    stmt                           shift and go to state 210
    compound_stmt                  shift and go to state 144
    single_stmt                    shift and go to state 145
    if_block                       shift and go to state 146
    for_block                      shift and go to state 147
    while_block                    shift and go to state 148
    declaration                    shift and go to state 149
    function_call                  shift and go to state 150
    prntf_call                     shift and go to state 152
    type                           shift and go to state 158
    declaration_list               shift and go to state 7
    unary_expr                     shift and go to state 8
    identifier                     shift and go to state 159
    data_type                      shift and go to state 9
    sub_decl                       shift and go to state 10
    sign_specifier                 shift and go to state 13
    type_specifier                 shift and go to state 14
    assignment_expr                shift and go to state 15
    array_access                   shift and go to state 16
    lhs                            shift and go to state 28

state 210

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt . after_loop
    (53) after_loop -> .

    BRP             reduce using rule 53 (after_loop -> .)
    BLP             reduce using rule 53 (after_loop -> .)
    RETURN          reduce using rule 53 (after_loop -> .)
    CONTINUE        reduce using rule 53 (after_loop -> .)
    BREAK           reduce using rule 53 (after_loop -> .)
    IF              reduce using rule 53 (after_loop -> .)
    FOR             reduce using rule 53 (after_loop -> .)
    WHILE           reduce using rule 53 (after_loop -> .)
    PRNTF           reduce using rule 53 (after_loop -> .)
    DECREMENT       reduce using rule 53 (after_loop -> .)
    INCREMENT       reduce using rule 53 (after_loop -> .)
    IDENTIFIER      reduce using rule 53 (after_loop -> .)
    SIGNED          reduce using rule 53 (after_loop -> .)
    UNSIGNED        reduce using rule 53 (after_loop -> .)
    INT             reduce using rule 53 (after_loop -> .)
    SHORT           reduce using rule 53 (after_loop -> .)
    LONG            reduce using rule 53 (after_loop -> .)
    LONG_LONG       reduce using rule 53 (after_loop -> .)
    CHAR            reduce using rule 53 (after_loop -> .)
    FLOAT           reduce using rule 53 (after_loop -> .)
    VOID            reduce using rule 53 (after_loop -> .)
    CHAR_STAR       reduce using rule 53 (after_loop -> .)
    ELSE            reduce using rule 53 (after_loop -> .)

    after_loop                     shift and go to state 211

state 211

    (51) for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .

    BRP             reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    BLP             reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    RETURN          reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    CONTINUE        reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    BREAK           reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    IF              reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    FOR             reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    WHILE           reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    PRNTF           reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    DECREMENT       reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    INCREMENT       reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    IDENTIFIER      reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    SIGNED          reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    UNSIGNED        reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    INT             reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    SHORT           reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    LONG            reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    LONG_LONG       reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    CHAR            reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    FLOAT           reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    VOID            reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    CHAR_STAR       reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)
    ELSE            reduce using rule 51 (for_block -> FOR LP expression_stmt M expression_stmt M expression RP before_loop N M stmt after_loop .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 194 resolved as shift
